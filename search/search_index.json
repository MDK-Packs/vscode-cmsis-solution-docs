{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Arm Keil Studio The Arm\u00ae Keil Studio extension pack for VS Code is a comprehensive software development platform for Arm Cortex-M processor-based devices. The IDE: supports single and multi-core processor systems, including Ethos-U NPUs. has wide software support for projects based on CMSIS, FreeRTOS, RTX, and Zephyr. utilizes CMSIS-Pack content to configure debug adapters and access re-usable software components. can be combined with other VS Code debug extensions, such as those for Linux application development. Contents Installation explains how to install Keil Studio along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the GUI. Create new solution explains how to start an embedded project from scratch. Manage solution explains how to configure a csolution project . Software components shows how to add or remove software components in a solution. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the csolution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues. Revision history Version Description 1.55.0 Rework for better clarity 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Home"},{"location":"index.html#arm-keil-studio","text":"The Arm\u00ae Keil Studio extension pack for VS Code is a comprehensive software development platform for Arm Cortex-M processor-based devices. The IDE: supports single and multi-core processor systems, including Ethos-U NPUs. has wide software support for projects based on CMSIS, FreeRTOS, RTX, and Zephyr. utilizes CMSIS-Pack content to configure debug adapters and access re-usable software components. can be combined with other VS Code debug extensions, such as those for Linux application development.","title":"Arm Keil Studio"},{"location":"index.html#contents","text":"Installation explains how to install Keil Studio along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the GUI. Create new solution explains how to start an embedded project from scratch. Manage solution explains how to configure a csolution project . Software components shows how to add or remove software components in a solution. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the csolution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues.","title":"Contents"},{"location":"index.html#revision-history","text":"Version Description 1.55.0 Rework for better clarity 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Revision history"},{"location":"conf_debug.html","text":"Configure Run and Debug When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. CMSIS View - Action buttons The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run . Run and Debug - Request The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Configure Run and Debug"},{"location":"conf_debug.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"conf_debug.html#cmsis-view-action-buttons","text":"The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run .","title":"CMSIS View - Action buttons"},{"location":"conf_debug.html#run-and-debug-request","text":"The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core.","title":"Run and Debug - Request"},{"location":"conf_debug.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"conf_debug.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"conf_debug.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"configuration.html","text":"Configuration Configure the extension Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used. Configure a solution If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file. Configure a build task In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks. Configure Run and Debug When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry . Enhancing the Debug Experience To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following. csolution.yml In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler cproject.yml In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"Configuration"},{"location":"configuration.html#configuration","text":"","title":"Configuration"},{"location":"configuration.html#configure-the-extension","text":"Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used.","title":"Configure the extension"},{"location":"configuration.html#configure-a-solution","text":"If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file.","title":"Configure a solution"},{"location":"configuration.html#configure-a-build-task","text":"In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks.","title":"Configure a build task"},{"location":"configuration.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"configuration.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"configuration.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"configuration.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"configuration.html#enhancing-the-debug-experience","text":"To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following.","title":"Enhancing the Debug Experience"},{"location":"configuration.html#csolutionyml","text":"In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler","title":"csolution.yml"},{"location":"configuration.html#cprojectyml","text":"In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"cproject.yml"},{"location":"create_app.html","text":"Create new solution This section explains how to create a CMSIS solution-based project that is using CMSIS-Packs. In the CMSIS view, click Create a New Solution . If you already have a solution opened, use the menu ( ... ) item Create a Solution . The Create new solution dialog allows to start projects based on a Target Board or Target Device selection. Examples, templates, and reference applications depend on the selected board or device and on installed CMSIS-Packs. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These projects require the installation of related CMSIS-Packs and additional software layers for an evaluation board. Templates are stub projects that help you getting started. Some CMSIS-Packs may contain device-specific templates. Further settings include: The Solution Sub Folder is typically a sub-directory in your workspace. The Solution Base Folder specifies your workspace location that may contain multiple projects. With Initialize Git repository the related .gitignore file is created. Show project opening options allows you to open the solution a new instance of VS Code. By default, it is loaded into the current VS Code instance. Work with examples Click the Target Board (Optional) drop-down list. Enter a search term tp filter the list and then select your board. The details of the selected board are displayed. Click Select . Next, select the example project. There are two types of example projects (available either from Local packs and/or from the Web ): Csolution Examples are using Keil Studio's native project format. uVision Examples are in *.uvprojx format and are converted automatically. To verify the Keil Studio installation, select a Blinky project for example. Specify a Solution Base Folder and click Create . Note First time users may need to confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in a project. A typical Blinky example includes a REAMDE.md file that contains valuable information about the hardware setup and specific tasks that need to be done before working with the target board: Continue to build the project . Work with reference applications Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with these CMSIS-Packs: MDK-Middleware : use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. SDS Framework : record real-world data off a device and playing it back on Arm Virtual Hardware. LiteRT : demonstrates the fundamental integration and usage of the LiteRT stack for ML inference on a microcontroller. Attention You need to have the CMSIS-Packs installed before you can create a new reference application. Please follow the instruction for installing packs . Configuration Reference applications use software layers that help scaling example projects to many different target boards. To be able to use the selected board with the reference application, you need to configure the solution and select an appropriate layer. More information about the layer requirements and other configuration options can be found in the documentation: MDK-Middleware SDS Framework Documentation Continue to build the project . Work with templates Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Continue to build the project . Build Before you can download the application on your target device, you need to build it. There are various ways to trigger a build: In the Explorer view , right-click the *.csolution.yml file and select Build solution . In the CMSIS view , click . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Continue to load and run the solution. Build output After you initiate the build process, a Terminal opens and displays the build operation: Execute: cbuild /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/Blinky.csolution.yml --active NUCLEO-F756ZG --packs +--------------------------------------------------- (1/1) Building context: \"Blinky.Debug+NUCLEO-F756ZG\" Using AC6 V6.24.0 compiler, from: '/Users/user/.vcpkg/artifacts/2139c4c6/compilers.arm.armclang/6.24.0/bin/' Building CMake target 'Blinky.Debug+NUCLEO-F756ZG' [1/51] Building C object CMakeFiles/Group_Source_Files_retarget_stdio_c.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/retarget_stdio.o [2/51] Building ASM object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/MDK-ARM/startup_stm32f756xx.o Warning: A1950W: The legacy armasm assembler is deprecated. Consider using the armclang integrated assembler instead. 0 Errors, 1 Warning [3/51] Building C object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/Src/stm32f7xx_hal_timebase_tim.o ... [49/51] Building C object CMakeFiles/Keil_CMSIS_Driver_USART_3_0_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-Driver_STM32/1.1.0/Drivers/USART_STM32.o [50/51] Building C object CMakeFiles/ARM_CMSIS_RTOS2_Keil_RTX5_Source_5_9_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-RTX/5.9.0/Source/rtx_thread.o [51/51] Linking C executable /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/out/Blinky/NUCLEO-F756ZG/Debug/Blinky.axf Program Size: Code=31972 RO-data=1076 RW-data=512 ZI-data=38760 +------------------------------------------------------------ Build summary: 1 succeeded, 0 failed - Time Elapsed: 00:00:04 +============================================================ Completed: cbuild succeed with exit code 0 Build complete The output directory usually contains an ELF ( .axf ) and a HEX ( .hex ) file. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox. To learn about the solution structure, refer to CMSIS-Toolbox documentation Load and Run Check target information In the CMSIS view, click and then select \"Target Information\" to check that your target is connected. In the Terminal , the result of the pyocd list command is shown: * Executing task: pyocd list --cbuild-run /Users/user/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml # Probe/Board Unique ID Target ------------------------------------------------------------------- 0 STLINK-V3 001000254D46501220383832 \u2716\ufe0e stm32u585aiix B-U585I-IOT02A Note If your debug adapter is not shown, make sure that all drivers are installed and that the target is connected to the PC. Download and run the application In the CMSIS view, click . This executes the \"Load & Run application\" command that executes the commands CMSIS Load and CMSIS Run from the tasks.json file. This flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: * Executing task: pyocd load --probe stlink: --cbuild-run /Users/user/B-U585-Board/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml 0000712 I Loading /Users/user/B-U585-Board/Blinky/out/Blinky/B-U585I-IOT02A/Debug/Blinky.axf [load_cmd] [==================================================] 100% 0003015 I Erased 49152 bytes (6 sectors), programmed 49152 bytes (48 pages), skipped 0 bytes (0 pages) at 20.96 kB/s [loader] * Terminal will be reused by tasks, press any key to close it. * Executing task: pyocd gdbserver --probe stlink: --connect attach --persist --reset-run --cbuild-run /Users/user/B-U585-Board/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml 0000251 I Target type is stm32u585aiix [board] 0000434 I DP IDR = 0x0be12477 (v2 MINDP rev0) [dap] 0000511 I debugvar 'DbgMCU_AHB1_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_AHB3_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB1H_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB1L_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB2_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB3_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_CR' = 0x6 (6) [cbuild_run] 0000511 I debugvar 'DoOptionByteLoading' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'TraceClk_Pin' = 0x40002 (262146) [cbuild_run] 0000511 I debugvar 'TraceD0_Pin' = 0x20009 (131081) [cbuild_run] 0000511 I debugvar 'TraceD1_Pin' = 0x2000a (131082) [cbuild_run] 0000511 I debugvar 'TraceD2_Pin' = 0x40005 (262149) [cbuild_run] 0000511 I debugvar 'TraceD3_Pin' = 0x2000c (131084) [cbuild_run] 0000516 I AHB5-AP#0 IDR = 0x14770015 (AHB5-AP var1 rev1) [discovery] 0000517 I AHB5-AP#0 Class 0x1 ROM table #0 @ 0xe00fe000 (designer=020:ST part=482) [rom_table] 0000518 I [0]<e00ff000:ROM class=1 designer=43b:Arm part=4c9> [rom_table] 0000518 I AHB5-AP#0 Class 0x1 ROM table #1 @ 0xe00ff000 (designer=43b:Arm part=4c9) [rom_table] 0000520 I [0]<e000e000:SCS M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=2a04 devid=0:0:0> [rom_table] 0000520 I [1]<e0001000:DWT M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=1a02 devid=0:0:0> [rom_table] 0000521 I [2]<e0002000:BPU M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=1a03 devid=0:0:0> [rom_table] 0000522 I [3]<e0000000:ITM M33 class=9 designer=43b:Arm part=d21 devtype=43 archid=1a01 devid=0:0:0> [rom_table] 0000523 I [5]<e0041000:ETM M33 class=9 designer=43b:Arm part=d21 devtype=13 archid=4a13 devid=0:0:0> [rom_table] 0000524 I [6]<e0042000:CTI M33 class=9 designer=43b:Arm part=d21 devtype=14 archid=1a14 devid=40800:0:0> [rom_table] 0000524 I [1]<e0040000:TPIU M33 class=9 designer=43b:Arm part=d21 devtype=11 archid=0000 devid=ca1:0:0> [rom_table] 0000525 I [2]<e0044000:DBGMCU class=15 designer=020:ST part=000> [rom_table] 0000533 I CPU core #0: Cortex-M33 r0p4, v8.0-M architecture [cortex_m] 0000533 I Extensions: [DSP, FPU, FPU_V5, MPU] [cortex_m] 0000533 I FPU present: FPv5-SP-D16-M [cortex_m] 0000534 I Setting core #0 (Cortex-M33) default reset sequence to ResetSystem [cbuild_run] 0000534 I 4 hardware watchpoints [dwt] 0000537 I 8 hardware breakpoints, 1 literal comparators [fpb] 0000662 I Semihost server started on port 4444 (core 0) [server] 0000718 I GDB server started on port 3333 (core 0) [gdbserver] When running, changes to . Use it to stop the GDB session anytime. Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multi-core device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. Monitor printf messages Keil Studio includes the Serial Monitor extension that connects to the target's serial output port. If your example contains printf statements, use the Serial Monitor to observe them.","title":"Create New Solution"},{"location":"create_app.html#create-new-solution","text":"This section explains how to create a CMSIS solution-based project that is using CMSIS-Packs. In the CMSIS view, click Create a New Solution . If you already have a solution opened, use the menu ( ... ) item Create a Solution . The Create new solution dialog allows to start projects based on a Target Board or Target Device selection. Examples, templates, and reference applications depend on the selected board or device and on installed CMSIS-Packs. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These projects require the installation of related CMSIS-Packs and additional software layers for an evaluation board. Templates are stub projects that help you getting started. Some CMSIS-Packs may contain device-specific templates. Further settings include: The Solution Sub Folder is typically a sub-directory in your workspace. The Solution Base Folder specifies your workspace location that may contain multiple projects. With Initialize Git repository the related .gitignore file is created. Show project opening options allows you to open the solution a new instance of VS Code. By default, it is loaded into the current VS Code instance.","title":"Create new solution"},{"location":"create_app.html#work-with-examples","text":"Click the Target Board (Optional) drop-down list. Enter a search term tp filter the list and then select your board. The details of the selected board are displayed. Click Select . Next, select the example project. There are two types of example projects (available either from Local packs and/or from the Web ): Csolution Examples are using Keil Studio's native project format. uVision Examples are in *.uvprojx format and are converted automatically. To verify the Keil Studio installation, select a Blinky project for example. Specify a Solution Base Folder and click Create . Note First time users may need to confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in a project. A typical Blinky example includes a REAMDE.md file that contains valuable information about the hardware setup and specific tasks that need to be done before working with the target board: Continue to build the project .","title":"Work with examples"},{"location":"create_app.html#work-with-reference-applications","text":"Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with these CMSIS-Packs: MDK-Middleware : use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. SDS Framework : record real-world data off a device and playing it back on Arm Virtual Hardware. LiteRT : demonstrates the fundamental integration and usage of the LiteRT stack for ML inference on a microcontroller. Attention You need to have the CMSIS-Packs installed before you can create a new reference application. Please follow the instruction for installing packs .","title":"Work with reference applications"},{"location":"create_app.html#configuration","text":"Reference applications use software layers that help scaling example projects to many different target boards. To be able to use the selected board with the reference application, you need to configure the solution and select an appropriate layer. More information about the layer requirements and other configuration options can be found in the documentation: MDK-Middleware SDS Framework Documentation Continue to build the project .","title":"Configuration"},{"location":"create_app.html#work-with-templates","text":"Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Continue to build the project .","title":"Work with templates"},{"location":"create_app.html#build","text":"Before you can download the application on your target device, you need to build it. There are various ways to trigger a build: In the Explorer view , right-click the *.csolution.yml file and select Build solution . In the CMSIS view , click . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Continue to load and run the solution.","title":"Build"},{"location":"create_app.html#build-output","text":"After you initiate the build process, a Terminal opens and displays the build operation: Execute: cbuild /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/Blinky.csolution.yml --active NUCLEO-F756ZG --packs +--------------------------------------------------- (1/1) Building context: \"Blinky.Debug+NUCLEO-F756ZG\" Using AC6 V6.24.0 compiler, from: '/Users/user/.vcpkg/artifacts/2139c4c6/compilers.arm.armclang/6.24.0/bin/' Building CMake target 'Blinky.Debug+NUCLEO-F756ZG' [1/51] Building C object CMakeFiles/Group_Source_Files_retarget_stdio_c.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/retarget_stdio.o [2/51] Building ASM object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/MDK-ARM/startup_stm32f756xx.o Warning: A1950W: The legacy armasm assembler is deprecated. Consider using the armclang integrated assembler instead. 0 Errors, 1 Warning [3/51] Building C object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/Src/stm32f7xx_hal_timebase_tim.o ... [49/51] Building C object CMakeFiles/Keil_CMSIS_Driver_USART_3_0_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-Driver_STM32/1.1.0/Drivers/USART_STM32.o [50/51] Building C object CMakeFiles/ARM_CMSIS_RTOS2_Keil_RTX5_Source_5_9_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-RTX/5.9.0/Source/rtx_thread.o [51/51] Linking C executable /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/out/Blinky/NUCLEO-F756ZG/Debug/Blinky.axf Program Size: Code=31972 RO-data=1076 RW-data=512 ZI-data=38760 +------------------------------------------------------------ Build summary: 1 succeeded, 0 failed - Time Elapsed: 00:00:04 +============================================================ Completed: cbuild succeed with exit code 0 Build complete The output directory usually contains an ELF ( .axf ) and a HEX ( .hex ) file. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox. To learn about the solution structure, refer to CMSIS-Toolbox documentation","title":"Build output"},{"location":"create_app.html#load-and-run","text":"","title":"Load and Run"},{"location":"create_app.html#check-target-information","text":"In the CMSIS view, click and then select \"Target Information\" to check that your target is connected. In the Terminal , the result of the pyocd list command is shown: * Executing task: pyocd list --cbuild-run /Users/user/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml # Probe/Board Unique ID Target ------------------------------------------------------------------- 0 STLINK-V3 001000254D46501220383832 \u2716\ufe0e stm32u585aiix B-U585I-IOT02A Note If your debug adapter is not shown, make sure that all drivers are installed and that the target is connected to the PC.","title":"Check target information"},{"location":"create_app.html#download-and-run-the-application","text":"In the CMSIS view, click . This executes the \"Load & Run application\" command that executes the commands CMSIS Load and CMSIS Run from the tasks.json file. This flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: * Executing task: pyocd load --probe stlink: --cbuild-run /Users/user/B-U585-Board/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml 0000712 I Loading /Users/user/B-U585-Board/Blinky/out/Blinky/B-U585I-IOT02A/Debug/Blinky.axf [load_cmd] [==================================================] 100% 0003015 I Erased 49152 bytes (6 sectors), programmed 49152 bytes (48 pages), skipped 0 bytes (0 pages) at 20.96 kB/s [loader] * Terminal will be reused by tasks, press any key to close it. * Executing task: pyocd gdbserver --probe stlink: --connect attach --persist --reset-run --cbuild-run /Users/user/B-U585-Board/Blinky/Blinky+B-U585I-IOT02A.cbuild-run.yml 0000251 I Target type is stm32u585aiix [board] 0000434 I DP IDR = 0x0be12477 (v2 MINDP rev0) [dap] 0000511 I debugvar 'DbgMCU_AHB1_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_AHB3_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB1H_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB1L_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB2_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_APB3_Fz' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'DbgMCU_CR' = 0x6 (6) [cbuild_run] 0000511 I debugvar 'DoOptionByteLoading' = 0x0 (0) [cbuild_run] 0000511 I debugvar 'TraceClk_Pin' = 0x40002 (262146) [cbuild_run] 0000511 I debugvar 'TraceD0_Pin' = 0x20009 (131081) [cbuild_run] 0000511 I debugvar 'TraceD1_Pin' = 0x2000a (131082) [cbuild_run] 0000511 I debugvar 'TraceD2_Pin' = 0x40005 (262149) [cbuild_run] 0000511 I debugvar 'TraceD3_Pin' = 0x2000c (131084) [cbuild_run] 0000516 I AHB5-AP#0 IDR = 0x14770015 (AHB5-AP var1 rev1) [discovery] 0000517 I AHB5-AP#0 Class 0x1 ROM table #0 @ 0xe00fe000 (designer=020:ST part=482) [rom_table] 0000518 I [0]<e00ff000:ROM class=1 designer=43b:Arm part=4c9> [rom_table] 0000518 I AHB5-AP#0 Class 0x1 ROM table #1 @ 0xe00ff000 (designer=43b:Arm part=4c9) [rom_table] 0000520 I [0]<e000e000:SCS M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=2a04 devid=0:0:0> [rom_table] 0000520 I [1]<e0001000:DWT M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=1a02 devid=0:0:0> [rom_table] 0000521 I [2]<e0002000:BPU M33 class=9 designer=43b:Arm part=d21 devtype=00 archid=1a03 devid=0:0:0> [rom_table] 0000522 I [3]<e0000000:ITM M33 class=9 designer=43b:Arm part=d21 devtype=43 archid=1a01 devid=0:0:0> [rom_table] 0000523 I [5]<e0041000:ETM M33 class=9 designer=43b:Arm part=d21 devtype=13 archid=4a13 devid=0:0:0> [rom_table] 0000524 I [6]<e0042000:CTI M33 class=9 designer=43b:Arm part=d21 devtype=14 archid=1a14 devid=40800:0:0> [rom_table] 0000524 I [1]<e0040000:TPIU M33 class=9 designer=43b:Arm part=d21 devtype=11 archid=0000 devid=ca1:0:0> [rom_table] 0000525 I [2]<e0044000:DBGMCU class=15 designer=020:ST part=000> [rom_table] 0000533 I CPU core #0: Cortex-M33 r0p4, v8.0-M architecture [cortex_m] 0000533 I Extensions: [DSP, FPU, FPU_V5, MPU] [cortex_m] 0000533 I FPU present: FPv5-SP-D16-M [cortex_m] 0000534 I Setting core #0 (Cortex-M33) default reset sequence to ResetSystem [cbuild_run] 0000534 I 4 hardware watchpoints [dwt] 0000537 I 8 hardware breakpoints, 1 literal comparators [fpb] 0000662 I Semihost server started on port 4444 (core 0) [server] 0000718 I GDB server started on port 3333 (core 0) [gdbserver] When running, changes to . Use it to stop the GDB session anytime. Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multi-core device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window.","title":"Download and run the application"},{"location":"create_app.html#monitor-printf-messages","text":"Keil Studio includes the Serial Monitor extension that connects to the target's serial output port. If your example contains printf statements, use the Serial Monitor to observe them.","title":"Monitor printf messages"},{"location":"debug.html","text":"Debug the application Debugging is an essential task for every embedded developer. The CMSIS view offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features. Debug on hardware Attention Make sure that your project and target are set up correctly and that the project can be loaded and run . Keil Studio extension handles debugging as follows: For each processor core, one debug server port is created. The underlying protocol is GDB MI using a GDB server. The server accesses the processor core via JTAG or SWD through a corresponding debug adapter. Debug adapter support Keil Studio support various debug adapters and and GDB server implementations from different vendors: Most of the debug adapters (including ST-Link) are served by pyOCD using the Arm CMSIS Debugger extension . Segger J-Link Server is supported. Arm Debugger and the Arm Debugger extension are supported. You can also use Arm Keil \u00b5Vision for debugging a project. Using pyOCD pyOCD is a Python-based tool and API for debugging and programming. It supports many debug adapters via the CMSIS-DAP protocol. In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select one of the debug adapters named xyz@pyOCD . The following JSON files are created automatically: In the launch.json file, attach and launch configurations are added that let you attach the debug adapter to an already running GDB instance (for example when you have issued a load and run before) or launch a new debug session. In the tasks.json file, the tasks CMSIS Erase , CMSIS Load , and CMSIS Run are created. Note Before entering a debug session, make sure that you have met the prerequisites of your debug adapter. Command line usage pyOCD can be also used on the command line. In a Terminal , issue for example: pyocd list --cbuild-run MyProject+TargetHW.cbuild-run.yml // details of debug connection (scan JTAG, SWD) pyocd gdbserver --cbuild-run MyProject+TargetHW.cbuild-run.yml // start debug server, load command: flash pyocd load --cbuild-run MyProject+TargetHW.cbuild-run.yml // flash and run application pyocd erase --cbuild-run MyProject+TargetHW.cbuild-run.yml // erase image on device Selecting a debug adapter Todo Explain how to select a CMSIS-DAP probe in case multiple are connected. Using J-Link Server Attention Make sure that the J-Link software is installed on your machine before attempting to use a J-Link adapter. In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select \"JLink Server\". The following JSON files are created automatically: The tasks.json file is populated with CMSIS Erase , CMSIS Load , and CMSIS Run tasks. The launch.json file is populated with JLink (launch) and JLink (attach) configurations. Arm Debugger You can use the Arm Debugger with Keil Studio. Prerequisites Before you can launch a debug session using Arm Debugger, you need to: Install the Arm Debugger VS Code extension . Add the Arm Debugger to your vcpkg-configuration.json file, for example: \"arm:debuggers/arm/armdbg\": \"6.6.0\" Setup for Arm Debugger In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select one of the debug adapters named xyz@Arm-Debugger . The following JSON files are created automatically: In the launch.json file, attach and launch configurations are added that let you attach the debug adapter to an already running GDB instance (for example when you have issued a load and run before) or launch a new debug session. In the tasks.json file, the tasks CMSIS Erase , CMSIS Load , and CMSIS Run are created. Keil uVision Attention This only works on a Windows PC as \u00b5Vision runs on Windows. Debug in simulation","title":"Debug"},{"location":"debug.html#debug-the-application","text":"Debugging is an essential task for every embedded developer. The CMSIS view offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features.","title":"Debug the application"},{"location":"debug.html#debug-on-hardware","text":"Attention Make sure that your project and target are set up correctly and that the project can be loaded and run . Keil Studio extension handles debugging as follows: For each processor core, one debug server port is created. The underlying protocol is GDB MI using a GDB server. The server accesses the processor core via JTAG or SWD through a corresponding debug adapter.","title":"Debug on hardware"},{"location":"debug.html#debug-adapter-support","text":"Keil Studio support various debug adapters and and GDB server implementations from different vendors: Most of the debug adapters (including ST-Link) are served by pyOCD using the Arm CMSIS Debugger extension . Segger J-Link Server is supported. Arm Debugger and the Arm Debugger extension are supported. You can also use Arm Keil \u00b5Vision for debugging a project.","title":"Debug adapter support"},{"location":"debug.html#using-pyocd","text":"pyOCD is a Python-based tool and API for debugging and programming. It supports many debug adapters via the CMSIS-DAP protocol. In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select one of the debug adapters named xyz@pyOCD . The following JSON files are created automatically: In the launch.json file, attach and launch configurations are added that let you attach the debug adapter to an already running GDB instance (for example when you have issued a load and run before) or launch a new debug session. In the tasks.json file, the tasks CMSIS Erase , CMSIS Load , and CMSIS Run are created. Note Before entering a debug session, make sure that you have met the prerequisites of your debug adapter.","title":"Using pyOCD"},{"location":"debug.html#command-line-usage","text":"pyOCD can be also used on the command line. In a Terminal , issue for example: pyocd list --cbuild-run MyProject+TargetHW.cbuild-run.yml // details of debug connection (scan JTAG, SWD) pyocd gdbserver --cbuild-run MyProject+TargetHW.cbuild-run.yml // start debug server, load command: flash pyocd load --cbuild-run MyProject+TargetHW.cbuild-run.yml // flash and run application pyocd erase --cbuild-run MyProject+TargetHW.cbuild-run.yml // erase image on device","title":"Command line usage"},{"location":"debug.html#selecting-a-debug-adapter","text":"Todo Explain how to select a CMSIS-DAP probe in case multiple are connected.","title":"Selecting a debug adapter"},{"location":"debug.html#using-j-link-server","text":"Attention Make sure that the J-Link software is installed on your machine before attempting to use a J-Link adapter. In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select \"JLink Server\". The following JSON files are created automatically: The tasks.json file is populated with CMSIS Erase , CMSIS Load , and CMSIS Run tasks. The launch.json file is populated with JLink (launch) and JLink (attach) configurations.","title":"Using J-Link Server"},{"location":"debug.html#arm-debugger","text":"You can use the Arm Debugger with Keil Studio.","title":"Arm Debugger"},{"location":"debug.html#prerequisites","text":"Before you can launch a debug session using Arm Debugger, you need to: Install the Arm Debugger VS Code extension . Add the Arm Debugger to your vcpkg-configuration.json file, for example: \"arm:debuggers/arm/armdbg\": \"6.6.0\"","title":"Prerequisites"},{"location":"debug.html#setup-for-arm-debugger","text":"In the CMSIS view , open the Manage Solution dialog and go to the Debug Adapter section . Select one of the debug adapters named xyz@Arm-Debugger . The following JSON files are created automatically: In the launch.json file, attach and launch configurations are added that let you attach the debug adapter to an already running GDB instance (for example when you have issued a load and run before) or launch a new debug session. In the tasks.json file, the tasks CMSIS Erase , CMSIS Load , and CMSIS Run are created.","title":"Setup for Arm Debugger"},{"location":"debug.html#keil-uvision","text":"Attention This only works on a Windows PC as \u00b5Vision runs on Windows.","title":"Keil uVision"},{"location":"debug.html#debug-in-simulation","text":"","title":"Debug in simulation"},{"location":"importuv.html","text":"Import a Keil \u00b5Vision project In Keil Studio, you can convert a Keil \u03bcVision project to a CMSIS solution by opening the folder that contains the *.uvprojx file that you want to convert. Then, do one of the following: From the Explorer view , right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . From the CMSIS view , choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored. Caveats Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see. Using Arm Compiler 5 The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Solution Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide . Using dollar sign in linker misc controls In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: This will cause a malformed YML access sequence in the generated cproject.yml file that will fail during builds. Solution Remove the $ sign and save the project in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Using dots in project file names In \u00b5Vision project names, you can use the dot, e.g. MyProject_1.0.uvprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Thus, using dots in project names will lead to: error csolution: schema check failed, verify syntax Solution Remove dots from project names. Project located in paths containing a dollar sign In some operating systems, paths can contain the dollar ( $ ) sign. Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Solution Use the -O option to redirect all output to a directory without the $ sign. Component mismatches when using generators Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Solution Delete the corresponding line from the cproject.yml file.","title":"Import uVision Project"},{"location":"importuv.html#import-a-keil-vision-project","text":"In Keil Studio, you can convert a Keil \u03bcVision project to a CMSIS solution by opening the folder that contains the *.uvprojx file that you want to convert. Then, do one of the following: From the Explorer view , right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . From the CMSIS view , choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored.","title":"Import a Keil \u00b5Vision project"},{"location":"importuv.html#caveats","text":"Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see.","title":"Caveats"},{"location":"importuv.html#using-arm-compiler-5","text":"The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Solution Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide .","title":"Using Arm Compiler 5"},{"location":"importuv.html#using-dollar-sign-in-linker-misc-controls","text":"In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: This will cause a malformed YML access sequence in the generated cproject.yml file that will fail during builds. Solution Remove the $ sign and save the project in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code.","title":"Using dollar sign in linker misc controls"},{"location":"importuv.html#using-dots-in-project-file-names","text":"In \u00b5Vision project names, you can use the dot, e.g. MyProject_1.0.uvprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Thus, using dots in project names will lead to: error csolution: schema check failed, verify syntax Solution Remove dots from project names.","title":"Using dots in project file names"},{"location":"importuv.html#project-located-in-paths-containing-a-dollar-sign","text":"In some operating systems, paths can contain the dollar ( $ ) sign. Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Solution Use the -O option to redirect all output to a directory without the $ sign.","title":"Project located in paths containing a dollar sign"},{"location":"importuv.html#component-mismatches-when-using-generators","text":"Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Solution Delete the corresponding line from the cproject.yml file.","title":"Component mismatches when using generators"},{"location":"installation.html","text":"Installation Prerequisites Arm Keil Studio is a set of extensions for Microsoft Visual Studio Code , which is required to be installed on your machine. Installing Keil Studio The Arm Keil Studio Pack (MDK v6) extension pack includes the extensions that are required to work with CMSIS solution projects. In VS Code, open the Extensions view. Type Arm in the search bar. Click on \"Arm Kei Studio Pack\" and README is shown on the right. It contains links to the included extensions. Their READMEs include minimal user guides. Click Install to start. You need to trust the publishers \"Arm\" and \"LLVM\" to install the extension pack. When the installation is finished, the CMSIS view icon appears in the activity bar. Verify the installation Once you have installed Keil Studio, you can verify your installation by following the getting started guide that opens automatically: It's best practice to create a new CMSIS solution based on a Blinky example, which typically flashes an LED on a target board. Note When creating a solution based on an example, all required tools and packs are installed automatically. Set up a new workspace If you want to install tools and packs separately, you have to create a new workspace in VS Code by opening a blank folder. Tool installation Required tools (such as a compiler toolchain or the CMSIS-Toolbox) are installed via the Arm Tools Environment Manager , controlled by the vcpkg-configuration.json file. Open the Arm Tools Environment Manager via the command pallette (Ctrl/CMd + Shift + p) and select Arm Tools: Configure Arm Tools Environment . The \"Arm Registry\" opens: Select at least an \"Arm CMSIS-Toolbox\" version as this is required to be able to install packs . The Output pane shows the status of the \"Arm Tools\" installation. Attention If you are using Keil Studio for the first time, the Arm Tools Environment Manager needs to download required tools from the Internet. While may take a couple of minutes (depending on your internet connection), it is only required once. You also need to provide a license. A free, non-commercial MDK-Community license can be activated from within the tool. If you need a commercial license, check our eStore or contact your preferred distributor . Pack installation CMSIS-Packs for device and board support as well as software delivery mechanism are an integral part of a CMSIS solution. Packs can be discovered online: List of CMSIS-Packs List of devices List of boards Each page contains information about how to download a pack with cpackget : Run this command in a Terminal (you will be asked to accept the license agreement): \u276f cpackget add Keil::MDK-Middleware@8.0.0 I: Updating public index I: Downloading index.pidx... I: 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| (216/216 kB, 405 kB/s) I: Updating PDSC files of public packs I: Adding pack \"Keil::MDK-Middleware@8.0.0\" I: Extracting files to /Users/chrsei01/.cache/arm/packs/Keil/MDK-Middleware/8.0.0... I: 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| (2180/2180, 2187 it/s)","title":"Installation"},{"location":"installation.html#installation","text":"","title":"Installation"},{"location":"installation.html#prerequisites","text":"Arm Keil Studio is a set of extensions for Microsoft Visual Studio Code , which is required to be installed on your machine.","title":"Prerequisites"},{"location":"installation.html#installing-keil-studio","text":"The Arm Keil Studio Pack (MDK v6) extension pack includes the extensions that are required to work with CMSIS solution projects. In VS Code, open the Extensions view. Type Arm in the search bar. Click on \"Arm Kei Studio Pack\" and README is shown on the right. It contains links to the included extensions. Their READMEs include minimal user guides. Click Install to start. You need to trust the publishers \"Arm\" and \"LLVM\" to install the extension pack. When the installation is finished, the CMSIS view icon appears in the activity bar.","title":"Installing Keil Studio"},{"location":"installation.html#verify-the-installation","text":"Once you have installed Keil Studio, you can verify your installation by following the getting started guide that opens automatically: It's best practice to create a new CMSIS solution based on a Blinky example, which typically flashes an LED on a target board. Note When creating a solution based on an example, all required tools and packs are installed automatically.","title":"Verify the installation"},{"location":"installation.html#set-up-a-new-workspace","text":"If you want to install tools and packs separately, you have to create a new workspace in VS Code by opening a blank folder.","title":"Set up a new workspace"},{"location":"installation.html#tool-installation","text":"Required tools (such as a compiler toolchain or the CMSIS-Toolbox) are installed via the Arm Tools Environment Manager , controlled by the vcpkg-configuration.json file. Open the Arm Tools Environment Manager via the command pallette (Ctrl/CMd + Shift + p) and select Arm Tools: Configure Arm Tools Environment . The \"Arm Registry\" opens: Select at least an \"Arm CMSIS-Toolbox\" version as this is required to be able to install packs . The Output pane shows the status of the \"Arm Tools\" installation. Attention If you are using Keil Studio for the first time, the Arm Tools Environment Manager needs to download required tools from the Internet. While may take a couple of minutes (depending on your internet connection), it is only required once. You also need to provide a license. A free, non-commercial MDK-Community license can be activated from within the tool. If you need a commercial license, check our eStore or contact your preferred distributor .","title":"Tool installation"},{"location":"installation.html#pack-installation","text":"CMSIS-Packs for device and board support as well as software delivery mechanism are an integral part of a CMSIS solution. Packs can be discovered online: List of CMSIS-Packs List of devices List of boards Each page contains information about how to download a pack with cpackget : Run this command in a Terminal (you will be asked to accept the license agreement): \u276f cpackget add Keil::MDK-Middleware@8.0.0 I: Updating public index I: Downloading index.pidx... I: 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| (216/216 kB, 405 kB/s) I: Updating PDSC files of public packs I: Adding pack \"Keil::MDK-Middleware@8.0.0\" I: Extracting files to /Users/chrsei01/.cache/arm/packs/Keil/MDK-Middleware/8.0.0... I: 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| (2180/2180, 2187 it/s)","title":"Pack installation"},{"location":"manage_components.html","text":"Software components A software component encapsulates a set of related functions. The Software Components view shows all the software components selected in the active project of a solution. You can: Modify the software components of the project. Manage the dependencies between components for each target type defined in your solution, or for all the target types at once. Software Components view Open the CMSIS view and click to open the Software Components view: You can: Switch between components and software packs . View only components that are part of the csolution or components from all installed packs . Set the context for which the component selection applies (including layers). Select/remove software components. View more information about the component (name, pack, version, and description). Select different variants of a component. Open related documentation . Validation In the Software Components view , you can manage the dependencies between components and solve validation issues. Issues are highlighted with a yellow exclamation mark icon . If there are validation issues: Either click on and select the issue in the pop-up box (a) or Click the \"Resolve\" button for access to the pop-up box (a). Once a components with validation issues is opened, you can use the \"eye\" icon to see which component is missing/affected (b). Use the \"Apply\" button to select the missing components (only available if there is no choice between different components available). When done, don't forget to Save the changes!","title":"Software Components"},{"location":"manage_components.html#software-components","text":"A software component encapsulates a set of related functions. The Software Components view shows all the software components selected in the active project of a solution. You can: Modify the software components of the project. Manage the dependencies between components for each target type defined in your solution, or for all the target types at once.","title":"Software components"},{"location":"manage_components.html#software-components-view","text":"Open the CMSIS view and click to open the Software Components view: You can: Switch between components and software packs . View only components that are part of the csolution or components from all installed packs . Set the context for which the component selection applies (including layers). Select/remove software components. View more information about the component (name, pack, version, and description). Select different variants of a component. Open related documentation .","title":"Software Components view"},{"location":"manage_components.html#validation","text":"In the Software Components view , you can manage the dependencies between components and solve validation issues. Issues are highlighted with a yellow exclamation mark icon . If there are validation issues: Either click on and select the issue in the pop-up box (a) or Click the \"Resolve\" button for access to the pop-up box (a). Once a components with validation issues is opened, you can use the \"eye\" icon to see which component is missing/affected (b). Use the \"Apply\" button to select the missing components (only available if there is no choice between different components available). When done, don't forget to Save the changes!","title":"Validation"},{"location":"manage_settings.html","text":"Manage Solution In the Manage Solution view, you can select the target, projects, and build types that are included in the application image. You can also specify the debug adapter that you are using for target connectivity. In the CMSIS view , click to open the Manage Solution view: Context Set In the Context Set section, you can change the active target type, and the active projects included in the build, as well as the build type of a project. Active Target Select a Target Type to specify the hardware used to build the solution for. To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml . Active Projects Select the project(s) that are part of the solution. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file. Errors and warnings You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense . Debug Adapter Use this drop-down to select the debug adapter that you are using for target connectivity. A broad range of adapters is supported. Some of them require further setup steps: CMSIS-DAP Infineon KitProg3 NXP MCU-Link Nuvoton Nu-Link Microchip PICkit Basic Segger J-Link STMicroelectronics ST-Link","title":"Manage Solution"},{"location":"manage_settings.html#manage-solution","text":"In the Manage Solution view, you can select the target, projects, and build types that are included in the application image. You can also specify the debug adapter that you are using for target connectivity. In the CMSIS view , click to open the Manage Solution view:","title":"Manage Solution"},{"location":"manage_settings.html#context-set","text":"In the Context Set section, you can change the active target type, and the active projects included in the build, as well as the build type of a project.","title":"Context Set"},{"location":"manage_settings.html#active-target","text":"Select a Target Type to specify the hardware used to build the solution for. To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml .","title":"Active Target"},{"location":"manage_settings.html#active-projects","text":"Select the project(s) that are part of the solution. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file.","title":"Active Projects"},{"location":"manage_settings.html#errors-and-warnings","text":"You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense .","title":"Errors and warnings"},{"location":"manage_settings.html#debug-adapter","text":"Use this drop-down to select the debug adapter that you are using for target connectivity. A broad range of adapters is supported. Some of them require further setup steps: CMSIS-DAP Infineon KitProg3 NXP MCU-Link Nuvoton Nu-Link Microchip PICkit Basic Segger J-Link STMicroelectronics ST-Link","title":"Debug Adapter"},{"location":"runexternal.html","text":"Run external tools VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases. Variables VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view. Substitution examples The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml Examples Arm Debugger Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] } Use \u00b5Vision for debugging The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Run External Tools"},{"location":"runexternal.html#run-external-tools","text":"VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases.","title":"Run external tools"},{"location":"runexternal.html#variables","text":"VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view.","title":"Variables"},{"location":"runexternal.html#substitution-examples","text":"The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml","title":"Substitution examples"},{"location":"runexternal.html#examples","text":"","title":"Examples"},{"location":"runexternal.html#arm-debugger","text":"Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] }","title":"Arm Debugger"},{"location":"runexternal.html#use-vision-for-debugging","text":"The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Use \u00b5Vision for debugging"},{"location":"tipsandtricks.html","text":"Tips and tricks This chapter contains useful information to help you solve specific issues. Create vcpkg configuration file If your solution does not contain the vcpkg-configuration.json , right-click anywhere in the workspace and select Configure Arm Tools Environment . The Arm Tools Environment Manager extension then generates this file. Set current solution in workspace To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions . Documentation does not open If you are using a Linux machine that uses the Snap package manager, your web browser will not be able to open documentation that is shipped in CMSIS-Packs as the CMSIS_PACK_ROOT directory is in ${HOME}/.cache/arm/packs which is not accessible to Snaps. Likewise, the Keil Studio help is located in ${HOME}/.vscode/extensions which is also not available. To get this working, use a browser that is not installed as a Snap package: Uninstall the Snap package. For example, run sudo snap remove firefox in a Terminal. Download the installer from the browser's web site. Install it on your machine. Installing debug adapters If you are using a third-party debug adapter, make sure that the latest drivers are installed on your machine Make sure the debug adapters are running the latest firmware and that the PATH variable is set correctly. Infineon KitProg3 Make sure that the latest firmware is installed . Microchip PICKit Basic Use the Python utility pycmsisdapswitcher to switch the firmware to a CMSIS-DAP v2 implementation. NXP MCU-Link Make sure that the latest firmware is installed . SEGGER J-Link For J-Link support, visit J-Link/J-Trace Downloads . Set the PATH variable to the bin directory of the installation. Verify the correct operation by entering the command jlink (Windows) or jlinkexe (Linux, macOS) in a Terminal. The output should similar to this: SEGGER J-Link Commander V8.24 (Compiled Mar 26 2025 15:34:18) DLL version V8.24, compiled Mar 26 2025 15:33:37 Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. J-Link> STMicroelectronics ST-Link For ST-LINK/V2 and ST-LINK/V2-1 support on Windows, download the USB driver here: STSW-LINK009 .","title":"Tips and Tricks"},{"location":"tipsandtricks.html#tips-and-tricks","text":"This chapter contains useful information to help you solve specific issues.","title":"Tips and tricks"},{"location":"tipsandtricks.html#create-vcpkg-configuration-file","text":"If your solution does not contain the vcpkg-configuration.json , right-click anywhere in the workspace and select Configure Arm Tools Environment . The Arm Tools Environment Manager extension then generates this file.","title":"Create vcpkg configuration file"},{"location":"tipsandtricks.html#set-current-solution-in-workspace","text":"To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions .","title":"Set current solution in workspace"},{"location":"tipsandtricks.html#documentation-does-not-open","text":"If you are using a Linux machine that uses the Snap package manager, your web browser will not be able to open documentation that is shipped in CMSIS-Packs as the CMSIS_PACK_ROOT directory is in ${HOME}/.cache/arm/packs which is not accessible to Snaps. Likewise, the Keil Studio help is located in ${HOME}/.vscode/extensions which is also not available. To get this working, use a browser that is not installed as a Snap package: Uninstall the Snap package. For example, run sudo snap remove firefox in a Terminal. Download the installer from the browser's web site. Install it on your machine.","title":"Documentation does not open"},{"location":"tipsandtricks.html#installing-debug-adapters","text":"If you are using a third-party debug adapter, make sure that the latest drivers are installed on your machine Make sure the debug adapters are running the latest firmware and that the PATH variable is set correctly.","title":"Installing debug adapters"},{"location":"tipsandtricks.html#infineon-kitprog3","text":"Make sure that the latest firmware is installed .","title":"Infineon KitProg3"},{"location":"tipsandtricks.html#microchip-pickit-basic","text":"Use the Python utility pycmsisdapswitcher to switch the firmware to a CMSIS-DAP v2 implementation.","title":"Microchip PICKit Basic"},{"location":"tipsandtricks.html#nxp-mcu-link","text":"Make sure that the latest firmware is installed .","title":"NXP MCU-Link"},{"location":"tipsandtricks.html#segger-j-link","text":"For J-Link support, visit J-Link/J-Trace Downloads . Set the PATH variable to the bin directory of the installation. Verify the correct operation by entering the command jlink (Windows) or jlinkexe (Linux, macOS) in a Terminal. The output should similar to this: SEGGER J-Link Commander V8.24 (Compiled Mar 26 2025 15:34:18) DLL version V8.24, compiled Mar 26 2025 15:33:37 Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. J-Link>","title":"SEGGER J-Link"},{"location":"tipsandtricks.html#stmicroelectronics-st-link","text":"For ST-LINK/V2 and ST-LINK/V2-1 support on Windows, download the USB driver here: STSW-LINK009 .","title":"STMicroelectronics ST-Link"},{"location":"userinterface.html","text":"User Interface The CMSIS Solution extension provides the Keil Studio GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment. CMSIS view The GUI consists of these elements: 1. Dedicated views from the side bar View Description Explorer view lists all local files. Search view enables search/replace across all files. Source Control view allows you to work with git. Extensions view lets you work with VS Code extensions. Run and Debug view switches the GUI to a dedicated debug view . CMSIS view is the main view for working with CMSIS solution-based projects. Note The ordering of the icons may be different in your VS Code environment. 2. Main area of the CMSIS view The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The main area of the CMSIS view shows: Board and device information and related documentation. Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files 3. Actions available through the CMSIS view Action Description Build solution calls the compiler toolchain and builds the solution. Load & Run application flashes the binary onto the target and starts the application. Load & Debug application flashes the binary onto the target and starts a debug session. Open csolution.yml file opens the CMSIS solution YML file for editing. Manage Solution Settings allows you to manage the solution settings. Shows further views and more actions. 4. Main area icons Depending on the file and the context, various icons may appear: Action Description IntelliSense is active for this cproject file. Open the file. Manage the software components of the cproject file. Add groups or files to the cproject file. 5. Status bar The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Status message of the clangd extension (used for IntelliSense). You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it. Run and Debug view The Run and Debug View in Keil Studio to the target using the request selection shown below. Select the core you want to launch or attach to. Interact with the cores. Run and Debug controls Depending on the target device (number of cores etc.), a similar run and debug control bar will be visible: or The icons enable access to: Icon Action Description Continue Resume normal program execution (up to the next breakpoint). Pause Inspect code executing at the current location. Step over Execute the next statement as a single command without inspecting or following its component steps. Step into Enter the next statement to follow its execution line-by-line. Step out When inside a function, return to the earlier execution context by completing remaining lines of the current method as though it were a single command. Restart Terminate the current program execution and start debugging again using the current run configuration. Stop Terminate the current debug session. Disconnect Detach debugger from a core without changing the execution status (running/pause). Reset Reset target device. Available commands You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view. When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution","title":"User Interface"},{"location":"userinterface.html#user-interface","text":"The CMSIS Solution extension provides the Keil Studio GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment.","title":"User Interface"},{"location":"userinterface.html#cmsis-view","text":"The GUI consists of these elements:","title":"CMSIS view"},{"location":"userinterface.html#1-dedicated-views-from-the-side-bar","text":"View Description Explorer view lists all local files. Search view enables search/replace across all files. Source Control view allows you to work with git. Extensions view lets you work with VS Code extensions. Run and Debug view switches the GUI to a dedicated debug view . CMSIS view is the main view for working with CMSIS solution-based projects. Note The ordering of the icons may be different in your VS Code environment.","title":"1. Dedicated views from the side bar"},{"location":"userinterface.html#2-main-area-of-the-cmsis-view","text":"The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The main area of the CMSIS view shows: Board and device information and related documentation. Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files","title":"2. Main area of the CMSIS view"},{"location":"userinterface.html#3-actions-available-through-the-cmsis-view","text":"Action Description Build solution calls the compiler toolchain and builds the solution. Load & Run application flashes the binary onto the target and starts the application. Load & Debug application flashes the binary onto the target and starts a debug session. Open csolution.yml file opens the CMSIS solution YML file for editing. Manage Solution Settings allows you to manage the solution settings. Shows further views and more actions.","title":"3. Actions available through the CMSIS view"},{"location":"userinterface.html#4-main-area-icons","text":"Depending on the file and the context, various icons may appear: Action Description IntelliSense is active for this cproject file. Open the file. Manage the software components of the cproject file. Add groups or files to the cproject file.","title":"4. Main area icons"},{"location":"userinterface.html#5-status-bar","text":"The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Status message of the clangd extension (used for IntelliSense). You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"5. Status bar"},{"location":"userinterface.html#run-and-debug-view","text":"The Run and Debug View in Keil Studio to the target using the request selection shown below. Select the core you want to launch or attach to. Interact with the cores.","title":"Run and Debug view"},{"location":"userinterface.html#run-and-debug-controls","text":"Depending on the target device (number of cores etc.), a similar run and debug control bar will be visible: or The icons enable access to: Icon Action Description Continue Resume normal program execution (up to the next breakpoint). Pause Inspect code executing at the current location. Step over Execute the next statement as a single command without inspecting or following its component steps. Step into Enter the next statement to follow its execution line-by-line. Step out When inside a function, return to the earlier execution context by completing remaining lines of the current method as though it were a single command. Restart Terminate the current program execution and start debugging again using the current run configuration. Stop Terminate the current debug session. Disconnect Detach debugger from a core without changing the execution status (running/pause). Reset Reset target device.","title":"Run and Debug controls"},{"location":"userinterface.html#available-commands","text":"You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view. When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution","title":"Available commands"}]}