{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CMSIS Solution extension The CMSIS Solution extension available for VS Code allows to create projects and build embedded applications that use CMSIS-Packs . It is a user interface for the CMSIS-Toolbox that supports various compilation tools including Arm Compiler 6, GCC, IAR, and LLVM. Contents Installation explains how to install the CMSIS Solution extension along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the CMSIS Solution extension GUI. Create an embedded project explains how to start a project from scratch. Manage software components shows how to add or remove software components in a solution. Manage solution settings explains how to configure a csolution project for run and debug. Build describes how to build a project. Load and run explains how to load and run an application on your hardware. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues. Revision history Version Description 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Home"},{"location":"index.html#cmsis-solution-extension","text":"The CMSIS Solution extension available for VS Code allows to create projects and build embedded applications that use CMSIS-Packs . It is a user interface for the CMSIS-Toolbox that supports various compilation tools including Arm Compiler 6, GCC, IAR, and LLVM.","title":"CMSIS Solution extension"},{"location":"index.html#contents","text":"Installation explains how to install the CMSIS Solution extension along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the CMSIS Solution extension GUI. Create an embedded project explains how to start a project from scratch. Manage software components shows how to add or remove software components in a solution. Manage solution settings explains how to configure a csolution project for run and debug. Build describes how to build a project. Load and run explains how to load and run an application on your hardware. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues.","title":"Contents"},{"location":"index.html#revision-history","text":"Version Description 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Revision history"},{"location":"build.html","text":"Build a project Before you can download the application on your target device, you need to build it. There are various ways to trigger a build. From the Explorer view In the Explorer view , right-click the *.csolution.yml file and select Build solution . These options are also available in the right-click menu: Rebuild solution : Cleans the output directories before building the cproject Clean all out and tmp directories : Cleans the output and tmp directories for the active solution From the CMSIS view In the header, click . The Clean all out and tmp directories and Rebuild solution options are also available with . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Build output After you initiate the build process, a Terminal window opens and displays the build operation: Check the output to find where the ELF file ( .axf ) was generated. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox.","title":"Build"},{"location":"build.html#build-a-project","text":"Before you can download the application on your target device, you need to build it. There are various ways to trigger a build.","title":"Build a project"},{"location":"build.html#from-the-explorer-view","text":"In the Explorer view , right-click the *.csolution.yml file and select Build solution . These options are also available in the right-click menu: Rebuild solution : Cleans the output directories before building the cproject Clean all out and tmp directories : Cleans the output and tmp directories for the active solution","title":"From the Explorer view"},{"location":"build.html#from-the-cmsis-view","text":"In the header, click . The Clean all out and tmp directories and Rebuild solution options are also available with . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details.","title":"From the CMSIS view"},{"location":"build.html#build-output","text":"After you initiate the build process, a Terminal window opens and displays the build operation: Check the output to find where the ELF file ( .axf ) was generated. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox.","title":"Build output"},{"location":"conf_debug.html","text":"Configure Run and Debug When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. CMSIS View - Action buttons The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run . Run and Debug - Request The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Configure Run and Debug"},{"location":"conf_debug.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"conf_debug.html#cmsis-view-action-buttons","text":"The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run .","title":"CMSIS View - Action buttons"},{"location":"conf_debug.html#run-and-debug-request","text":"The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core.","title":"Run and Debug - Request"},{"location":"conf_debug.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"conf_debug.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"conf_debug.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"configuration.html","text":"Configuration Configure the extension Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used. Configure a solution If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file. Configure a build task In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks. Configure Run and Debug When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Configuration"},{"location":"configuration.html#configuration","text":"","title":"Configuration"},{"location":"configuration.html#configure-the-extension","text":"Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used.","title":"Configure the extension"},{"location":"configuration.html#configure-a-solution","text":"If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file.","title":"Configure a solution"},{"location":"configuration.html#configure-a-build-task","text":"In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks.","title":"Configure a build task"},{"location":"configuration.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"configuration.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"configuration.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"configuration.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"create_app.html","text":"Create an embedded project This chapter explains how to create a CMSIS solution-based application. Create a new solution In the CMSIS view, click Create a New Solution to open the Create Solution view. Note If you already have a solution opened in your workspace and want to create a new one in the same workspace, move your cursor over the three dots ... in the CMSIS view, then click Create a Solution . Click the Target Board drop-down list. Enter a search term, and then select a board. The details of the board that you selected display. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Note Alternatively, you can directly select a device in the Target Device drop-down list, without selecting a board first. Select a template, a reference application, or an example Select one of the following options from the drop-down list. The options available depend on the board or device selected previously. If there are too many examples, enter a search term and then select an example. Templates Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Reference applications Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with the MDK-Middleware . These examples show you how to use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. See MDK Middleware Reference Applications and the MDK-Middleware repository and documentation for more details. Other reference applications that illustrate how to match sensor shields and boards are also available with the Sensor SDK pack. The examples use board and shield layers. See Sensor Reference Applications and the Sensor-SDK-Example repository for more details. Reference applications that use socket layers are also available. See the AWS MQTT demo as an example. Csolution examples CMSIS solution examples are targeted at a specific board or Fixed Virtual Platform (FVP) model. The examples are fully configured and ready for use. \u00b5Vision examples Use a \u00b5Vision example in *.uvprojx format as a starting point. \u00b5Vision examples are converted automatically. Project name After you have selected your solution template, specify a Project Name . If you selected Blank solution or TrustZone solution , one project for each processor is automatically added (for TrustZone, a secure and a non-secure project are added for each processor). You can: Change the project names Remove projects Decide to add secure or non-secure zones with the TrustZone drop-down list if the board or device is compatible. By default, TrustZone is off . Click Add Project to add projects to your solution and configure them. For TrustZone, you can add as many secure or non-secure projects as you need for a particular processor. Solution name If you selected Blank solution or TrustZone solution , you can change the name for your solution in the Solution Name field. This information is used as the <solution_name>.csolution.yml file name. Solution subfolder In the Solution Sub Folder field, you can change the name of the subfolder where the solution files are stored. Solution base folder Click Browse next to the Solution Base Folder field and choose where to store the solution subfolder using the system dialog box. With the Initialize Git repository checkbox, you can initialize the solution as a Git repository. Clear the checkbox if you do not want to turn your solution into a Git repository. Select the Show project opening options checkbox to decide where to open the solution. Click Create . The extension creates the solution and automatically converts examples that are available only in *.uvprojx format. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. Missing CMSIS-Packs are installed automatically. The following files are created for the solution: A <solution_name>.csolution.yml file One or more <project_name>.cproject.yml files, each available in a separate folder For reference applications only, each cproject.yml file contains a $Board-Layer$ variable For reference applications with sensor shields, each cproject.yml file contains a $Shield-Layer$ variable For reference applications with a socket layer, each cproject.yml file contains a $Socket-Layer$ variable. These variables are not yet defined. A main <filename>.c template file for each project A vcpkg-configuration.json file to download required tools automatically Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution before you can build the project.","title":"Create New Solution"},{"location":"create_app.html#create-an-embedded-project","text":"This chapter explains how to create a CMSIS solution-based application.","title":"Create an embedded project"},{"location":"create_app.html#create-a-new-solution","text":"In the CMSIS view, click Create a New Solution to open the Create Solution view. Note If you already have a solution opened in your workspace and want to create a new one in the same workspace, move your cursor over the three dots ... in the CMSIS view, then click Create a Solution . Click the Target Board drop-down list. Enter a search term, and then select a board. The details of the board that you selected display. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Note Alternatively, you can directly select a device in the Target Device drop-down list, without selecting a board first.","title":"Create a new solution"},{"location":"create_app.html#select-a-template-a-reference-application-or-an-example","text":"Select one of the following options from the drop-down list. The options available depend on the board or device selected previously. If there are too many examples, enter a search term and then select an example.","title":"Select a template, a reference application, or an example"},{"location":"create_app.html#templates","text":"Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones","title":"Templates"},{"location":"create_app.html#reference-applications","text":"Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with the MDK-Middleware . These examples show you how to use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. See MDK Middleware Reference Applications and the MDK-Middleware repository and documentation for more details. Other reference applications that illustrate how to match sensor shields and boards are also available with the Sensor SDK pack. The examples use board and shield layers. See Sensor Reference Applications and the Sensor-SDK-Example repository for more details. Reference applications that use socket layers are also available. See the AWS MQTT demo as an example.","title":"Reference applications"},{"location":"create_app.html#csolution-examples","text":"CMSIS solution examples are targeted at a specific board or Fixed Virtual Platform (FVP) model. The examples are fully configured and ready for use.","title":"Csolution examples"},{"location":"create_app.html#vision-examples","text":"Use a \u00b5Vision example in *.uvprojx format as a starting point. \u00b5Vision examples are converted automatically.","title":"\u00b5Vision examples"},{"location":"create_app.html#project-name","text":"After you have selected your solution template, specify a Project Name . If you selected Blank solution or TrustZone solution , one project for each processor is automatically added (for TrustZone, a secure and a non-secure project are added for each processor). You can: Change the project names Remove projects Decide to add secure or non-secure zones with the TrustZone drop-down list if the board or device is compatible. By default, TrustZone is off . Click Add Project to add projects to your solution and configure them. For TrustZone, you can add as many secure or non-secure projects as you need for a particular processor.","title":"Project name"},{"location":"create_app.html#solution-name","text":"If you selected Blank solution or TrustZone solution , you can change the name for your solution in the Solution Name field. This information is used as the <solution_name>.csolution.yml file name.","title":"Solution name"},{"location":"create_app.html#solution-subfolder","text":"In the Solution Sub Folder field, you can change the name of the subfolder where the solution files are stored.","title":"Solution subfolder"},{"location":"create_app.html#solution-base-folder","text":"Click Browse next to the Solution Base Folder field and choose where to store the solution subfolder using the system dialog box. With the Initialize Git repository checkbox, you can initialize the solution as a Git repository. Clear the checkbox if you do not want to turn your solution into a Git repository. Select the Show project opening options checkbox to decide where to open the solution. Click Create . The extension creates the solution and automatically converts examples that are available only in *.uvprojx format. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. Missing CMSIS-Packs are installed automatically. The following files are created for the solution: A <solution_name>.csolution.yml file One or more <project_name>.cproject.yml files, each available in a separate folder For reference applications only, each cproject.yml file contains a $Board-Layer$ variable For reference applications with sensor shields, each cproject.yml file contains a $Shield-Layer$ variable For reference applications with a socket layer, each cproject.yml file contains a $Socket-Layer$ variable. These variables are not yet defined. A main <filename>.c template file for each project A vcpkg-configuration.json file to download required tools automatically Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution before you can build the project.","title":"Solution base folder"},{"location":"debug.html","text":"Debug the application Debugging is an essential task for every embedded developer. The CMSIS View offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features. CMSIS View The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run . Run and Debug View The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core. Debug on hardware Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and debug\" command that flashes the project onto the target and starts a debug session. Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output.","title":"Debug"},{"location":"debug.html#debug-the-application","text":"Debugging is an essential task for every embedded developer. The CMSIS View offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features.","title":"Debug the application"},{"location":"debug.html#cmsis-view","text":"The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run .","title":"CMSIS View"},{"location":"debug.html#run-and-debug-view","text":"The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core.","title":"Run and Debug View"},{"location":"debug.html#debug-on-hardware","text":"Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and debug\" command that flashes the project onto the target and starts a debug session. Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output.","title":"Debug on hardware"},{"location":"flash.html","text":"Load and Run Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and run\" command that flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window.","title":"Load and Run"},{"location":"flash.html#load-and-run","text":"Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and run\" command that flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window.","title":"Load and Run"},{"location":"importuv.html","text":"Import a Keil \u00b5Vision project With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in VS Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored. Caveats Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see. Using Arm Compiler 5 The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide . Using dollar sign in linker misc controls In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds. Using dots in project file names In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" . Project located in paths containing a dollar sign In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign. Component mismatches when using generators Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Import uVision Project"},{"location":"importuv.html#import-a-keil-vision-project","text":"With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in VS Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored.","title":"Import a Keil \u00b5Vision project"},{"location":"importuv.html#caveats","text":"Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see.","title":"Caveats"},{"location":"importuv.html#using-arm-compiler-5","text":"The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide .","title":"Using Arm Compiler 5"},{"location":"importuv.html#using-dollar-sign-in-linker-misc-controls","text":"In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds.","title":"Using dollar sign in linker misc controls"},{"location":"importuv.html#using-dots-in-project-file-names","text":"In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" .","title":"Using dots in project file names"},{"location":"importuv.html#project-located-in-paths-containing-a-dollar-sign","text":"In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign.","title":"Project located in paths containing a dollar sign"},{"location":"importuv.html#component-mismatches-when-using-generators","text":"Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Component mismatches when using generators"},{"location":"installation.html","text":"Installation The Arm Keil Studio Pack (MDK v6) extension pack includes the CMSIS Solution extension and other extensions that you can use to work with CMSIS solution projects. In VS Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or verify the installation with an example projecy and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the Arm CMSIS Solution extension standalone. Search for CMSIS Solution in the Extensions view. Verify the installation The CMSIS boards list contains many examples that you can use to verify that the extension works correctly. The following example explains how to start from a Blinky project for the STMicroelectronics NUCLEO-F756ZG development board. Adapt the steps for your target hardware. In the CMSIS view, click Create a New Solution to open the Create Solution view. Click the Target Board drop-down list. Enter a search term, for example \"f756\", and then select the \"NUCLEO-F756ZG (Rev.B)\" board. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Click the Templates, Reference Applications, and Example drop-down list. Enter a search term, for example \"Blinky\", and then select the \"Blinky\" example from the web. Click Browse to set a base forlder for the solution, then click Create . Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in your project. Now you can now build and debug the example project. During the build process missing software packs may be downloaded.","title":"Installation"},{"location":"installation.html#installation","text":"The Arm Keil Studio Pack (MDK v6) extension pack includes the CMSIS Solution extension and other extensions that you can use to work with CMSIS solution projects. In VS Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or verify the installation with an example projecy and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the Arm CMSIS Solution extension standalone. Search for CMSIS Solution in the Extensions view.","title":"Installation"},{"location":"installation.html#verify-the-installation","text":"The CMSIS boards list contains many examples that you can use to verify that the extension works correctly. The following example explains how to start from a Blinky project for the STMicroelectronics NUCLEO-F756ZG development board. Adapt the steps for your target hardware. In the CMSIS view, click Create a New Solution to open the Create Solution view. Click the Target Board drop-down list. Enter a search term, for example \"f756\", and then select the \"NUCLEO-F756ZG (Rev.B)\" board. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Click the Templates, Reference Applications, and Example drop-down list. Enter a search term, for example \"Blinky\", and then select the \"Blinky\" example from the web. Click Browse to set a base forlder for the solution, then click Create . Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in your project. Now you can now build and debug the example project. During the build process missing software packs may be downloaded.","title":"Verify the installation"},{"location":"manage_components.html","text":"Manage software components The Software Components view shows all the software components selected in the active project of a solution. You can do the following: Modify the software components of the project Manage the dependencies between components for each target type defined in your solution, or for all the target types at once Software Components view Open the CMSIS view . In the Solution outline , click Manage software components at the project level. The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation. Modify the software components in your project You can add components from all the packs available, not just the packs that are already selected for a project. Modify the context displayed In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option. Select components Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated. Validation Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Manage Software Components"},{"location":"manage_components.html#manage-software-components","text":"The Software Components view shows all the software components selected in the active project of a solution. You can do the following: Modify the software components of the project Manage the dependencies between components for each target type defined in your solution, or for all the target types at once","title":"Manage software components"},{"location":"manage_components.html#software-components-view","text":"Open the CMSIS view . In the Solution outline , click Manage software components at the project level. The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation.","title":"Software Components view"},{"location":"manage_components.html#modify-the-software-components-in-your-project","text":"You can add components from all the packs available, not just the packs that are already selected for a project.","title":"Modify the software components in your project"},{"location":"manage_components.html#modify-the-context-displayed","text":"In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option.","title":"Modify the context displayed"},{"location":"manage_components.html#select-components","text":"Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated.","title":"Select components"},{"location":"manage_components.html#validation","text":"Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Validation"},{"location":"manage_settings.html","text":"Manage Solution Settings In the Manage Solution view, you can set the context of your solution. The context set selects the target and defines the projects and build types that are included in the application image. In the Solution outline , click Manage Solution Settings . The Manage Solutions view opens: You can change the active target type, and the active projects included in the build. You can also change the build type of a project, or the run and debug configurations, or you can add new configurations. Active target Select a Target Type to specify the hardware used to build the solution. Some examples are also compatible with Arm Virtual Hardware (AVH) targets, in which case more options are available. For more details, read the AVH solutions overview . To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml . Active projects This section shows the projects that are part of the solution. Use the checkboxes to add or remove projects from the context set. The Project Name displays and cannot be changed. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. YAML syntax support helps you with editing. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file. Run and debug Choose a run configuration and a debug configuration to use for your solution. You can select different run and debug configurations for each project included in the solution. You can also move your mouse over an entry in the list and click the pen icon to edit an existing configuration with a visual editor: Click + Add new to add a new configuration. Errors and warnings You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense .","title":"Manage Solution Settings"},{"location":"manage_settings.html#manage-solution-settings","text":"In the Manage Solution view, you can set the context of your solution. The context set selects the target and defines the projects and build types that are included in the application image. In the Solution outline , click Manage Solution Settings . The Manage Solutions view opens: You can change the active target type, and the active projects included in the build. You can also change the build type of a project, or the run and debug configurations, or you can add new configurations.","title":"Manage Solution Settings"},{"location":"manage_settings.html#active-target","text":"Select a Target Type to specify the hardware used to build the solution. Some examples are also compatible with Arm Virtual Hardware (AVH) targets, in which case more options are available. For more details, read the AVH solutions overview . To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml .","title":"Active target"},{"location":"manage_settings.html#active-projects","text":"This section shows the projects that are part of the solution. Use the checkboxes to add or remove projects from the context set. The Project Name displays and cannot be changed. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. YAML syntax support helps you with editing. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file.","title":"Active projects"},{"location":"manage_settings.html#run-and-debug","text":"Choose a run configuration and a debug configuration to use for your solution. You can select different run and debug configurations for each project included in the solution. You can also move your mouse over an entry in the list and click the pen icon to edit an existing configuration with a visual editor: Click + Add new to add a new configuration.","title":"Run and debug"},{"location":"manage_settings.html#errors-and-warnings","text":"You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense .","title":"Errors and warnings"},{"location":"runexternal.html","text":"Run external tools VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases. Variables VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view. Substitution examples The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml Examples pyOCD Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] } Arm Debugger Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] } Use \u00b5Vision for debugging The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Run External Tools"},{"location":"runexternal.html#run-external-tools","text":"VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases.","title":"Run external tools"},{"location":"runexternal.html#variables","text":"VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view.","title":"Variables"},{"location":"runexternal.html#substitution-examples","text":"The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml","title":"Substitution examples"},{"location":"runexternal.html#examples","text":"","title":"Examples"},{"location":"runexternal.html#pyocd","text":"Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] }","title":"pyOCD"},{"location":"runexternal.html#arm-debugger","text":"Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] }","title":"Arm Debugger"},{"location":"runexternal.html#use-vision-for-debugging","text":"The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Use \u00b5Vision for debugging"},{"location":"tipsandtricks.html","text":"Tips and tricks This chapter contains useful information to help you solve specific issues. Initialize your solution Examples from keil.arm.com or solutions you create from scratch from the Create Solution view are already initialized and contain all the required files. If your solution does not contain the vcpkg-configuration.json , tasks.json , and launch.json files, right-click anywhere in the workspace and select Initialize CMSIS project . The extension generates preconfigured files that are ready to use. Set current solution in workspace To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions . Enhancing the Debug Experience To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following. csolution.yml In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler cproject.yml In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"Tips and Tricks"},{"location":"tipsandtricks.html#tips-and-tricks","text":"This chapter contains useful information to help you solve specific issues.","title":"Tips and tricks"},{"location":"tipsandtricks.html#initialize-your-solution","text":"Examples from keil.arm.com or solutions you create from scratch from the Create Solution view are already initialized and contain all the required files. If your solution does not contain the vcpkg-configuration.json , tasks.json , and launch.json files, right-click anywhere in the workspace and select Initialize CMSIS project . The extension generates preconfigured files that are ready to use.","title":"Initialize your solution"},{"location":"tipsandtricks.html#set-current-solution-in-workspace","text":"To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions .","title":"Set current solution in workspace"},{"location":"tipsandtricks.html#enhancing-the-debug-experience","text":"To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following.","title":"Enhancing the Debug Experience"},{"location":"tipsandtricks.html#csolutionyml","text":"In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler","title":"csolution.yml"},{"location":"tipsandtricks.html#cprojectyml","text":"In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"cproject.yml"},{"location":"userinterface.html","text":"User Interface The CMSIS Solution extension for VS Code provides a GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment. This quick start section explains the commands and capabilities of the CMSIS view and the status bar . Available commands You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view . When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution CMSIS view The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The extension uses these settings and files to manage and build a software project for a board or device. The main area shows: Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files Status bar The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Here is an example of how the status bar can look: If you have a development board connected, the connected hardware displays using the Arm Device Manager extension. Click the connected hardware to open the extension. The current debug configuration displays using the Arm Debugger extension You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"User Interface"},{"location":"userinterface.html#user-interface","text":"The CMSIS Solution extension for VS Code provides a GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment. This quick start section explains the commands and capabilities of the CMSIS view and the status bar .","title":"User Interface"},{"location":"userinterface.html#available-commands","text":"You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view . When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution","title":"Available commands"},{"location":"userinterface.html#cmsis-view","text":"The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The extension uses these settings and files to manage and build a software project for a board or device. The main area shows: Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files","title":"CMSIS view"},{"location":"userinterface.html#status-bar","text":"The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Here is an example of how the status bar can look: If you have a development board connected, the connected hardware displays using the Arm Device Manager extension. Click the connected hardware to open the extension. The current debug configuration displays using the Arm Debugger extension You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"Status bar"}]}