{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Arm Keil Studio Arm Keil Studio for VS Code allows to create projects and build embedded applications that use CMSIS-Packs . It is a user interface for the CMSIS-Toolbox that supports various compilation tools including Arm Compiler 6, GCC, IAR, and LLVM. Contents Installation explains how to install Keil Studio along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the GUI. Create new solution explains how to start an embedded project from scratch. Manage solution explains how to configure a csolution project . Software components shows how to add or remove software components in a solution. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues. Revision history Version Description 1.5x.0 Rework for better clarity 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Home"},{"location":"index.html#arm-keil-studio","text":"Arm Keil Studio for VS Code allows to create projects and build embedded applications that use CMSIS-Packs . It is a user interface for the CMSIS-Toolbox that supports various compilation tools including Arm Compiler 6, GCC, IAR, and LLVM.","title":"Arm Keil Studio"},{"location":"index.html#contents","text":"Installation explains how to install Keil Studio along with a build environment for embedded applications that are based on Arm Cortex-M processors. User interface shows the main features available in the GUI. Create new solution explains how to start an embedded project from scratch. Manage solution explains how to configure a csolution project . Software components shows how to add or remove software components in a solution. Debug explains how to debug a project. Configuration explains how to manage the extension settings and some specific configuration options, for example for run and debug. Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format. Run external tools describes how to use external tools, such as debuggers and flash programmers. Tips and tricks provides tips and tricks to help you solve specific issues.","title":"Contents"},{"location":"index.html#revision-history","text":"Version Description 1.5x.0 Rework for better clarity 1.54.0 Added CMSIS-Toolbox Run and Debug Management 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Revision history"},{"location":"conf_debug.html","text":"Configure Run and Debug When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. CMSIS View - Action buttons The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run . Run and Debug - Request The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Configure Run and Debug"},{"location":"conf_debug.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"conf_debug.html#cmsis-view-action-buttons","text":"The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run .","title":"CMSIS View - Action buttons"},{"location":"conf_debug.html#run-and-debug-request","text":"The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core.","title":"Run and Debug - Request"},{"location":"conf_debug.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"conf_debug.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"conf_debug.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"configuration.html","text":"Configuration Configure the extension Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used. Configure a solution If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file. Configure a build task In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks. Configure Run and Debug When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system. Example The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example User Modifications to launch.json By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified Template Files Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry . Enhancing the Debug Experience To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following. csolution.yml In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler cproject.yml In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"Configuration"},{"location":"configuration.html#configuration","text":"","title":"Configuration"},{"location":"configuration.html#configure-the-extension","text":"Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used.","title":"Configure the extension"},{"location":"configuration.html#configure-a-solution","text":"If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file.","title":"Configure a solution"},{"location":"configuration.html#configure-a-build-task","text":"In VS Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks.","title":"Configure a build task"},{"location":"configuration.html#configure-run-and-debug","text":"When using the CMSIS-Toolbox 2.9.0, the Run and Debug Management file *.cbuild-run.yml provides all information to configure programmers or debuggers. With this information the CMSIS Solution extension generates the launch.json and tasks.json configuration files for the run and debug features of VS Code. Note The generation of the launch.json and tasks.json files is enabled when the csolution project contains a target-set: node. Using target-set: uses the cbuild command option --active to select the configuration. The option --context-set and the file *.cbuild-set.yml is no longer used. In VS Code, there are two debug request modes that can be configured in launch.json : Launch starts a debug session and typically stops at the main function. Attach connects a debug session to a running system.","title":"Configure Run and Debug"},{"location":"configuration.html#example","text":"The following *.csolution.yml file is configured for a CMSIS-DAP Debugger as shown below. Refer to the CMSIS-Toolbox users guide for details on target-set . solution: : target-types: - type: MyBoard_ROM # My evaluation kit (Execution from ROM) board: B-U585I-IOT02A # Board name as defined by the pack target-set: - set: # default configuration debugger: name: CMSIS-DAP # uses CMSIS-DAP The related *.cbuild-run.yml file contains the information for the debugger setup. The CMSIS Solution extension uses this information with a template file for a debug adapter (in this case for CMSIS-DAP) to update the configuration information in launch.json and tasks.json . ToDo: add the generated launch.json + tasks.json from this example","title":"Example"},{"location":"configuration.html#user-modifications-to-launchjson","text":"By default, the CMSIS Solution extension updates the launch.json file to reflect the settings in the csolution project . Sometimes the user needs control over settings. The cmsis: - updateConfiguration: value in the launch.json file controls the update. Remove auto to manually control the settings and this section. \"cmsis\": { \"pname\": cm33_core0 \"target-type\": MCXN947 \"updateConfiguration\": auto // without auto, this section is not modified","title":"User Modifications to launch.json"},{"location":"configuration.html#template-files","text":"Template files for various debug adapters are included in the installation. For reference the template files are provided in the Debug Adapter Registry . A template file in *.json format contains the following sections: \"launch\": // section for launch.json \"singlecore-launch\": // debugger launch request for single-core system \"singlecore-attach\": // debugger attach request for single-core system \"multicore-start-launch\": // debugger launch request for the start processor in multi-core system. \"multicore-start-attach\": // debugger attach request for the start processor in multi-core system. \"multicore-other\": // debugger attach request for other processors in multi-core system. \"tasks\": // section for tasks.json \"label\": \"CMSIS Load+Run\", // command \"CMSIS Load+Run\" \"label\": \"CMSIS Run\", // command \"CMSIS Run\" \"label\": \"CMSIS Load\", // command \"CMSIS Load\" \"label\": \"CMSIS Erase\", // command \"CMSIS Erase\" The template files are processed with the Eta template engine. It inserts data of the *.cbuild-run.yml file into the various sections of the template file using placeholders listed in the table below. Each section is processed depending on the system type. Placeholder Description solution_folder Relative path from the workspace folder to the directory that stores the *.csolution.yml file device_name From *.cbuild-run.yml : value of device: target_type From *.cbuild-run.yml : value of target-type: start_pname From *.cbuild-run.yml : value of start_pname: image_files From *.cbuild-run.yml : value list of output: with image information symbol_files From *.cbuild-run.yml : value list of output: with symbols information pname Processor name in a multi-core system that is currently processed by the template engine ports From *.cbuild-run.yml : value list of gdbserver: The usage of these placeholders is exemplified with the template files in the Debug Adapter Registry .","title":"Template Files"},{"location":"configuration.html#enhancing-the-debug-experience","text":"To ensure the best debug experience with Arm Compiler for Embedded, make sure that your CMSIS solution files contain the following.","title":"Enhancing the Debug Experience"},{"location":"configuration.html#csolutionyml","text":"In the *.csolution.yml file, insert the following block in - target-types\\- type section: target-set: - set: debugger: name: # set to name of your debug adapter Insert the following before the - projects section: misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler","title":"csolution.yml"},{"location":"configuration.html#cprojectyml","text":"In the *.cproject.yml file, add at the end: output: type: - elf - hex - map","title":"cproject.yml"},{"location":"create_app.html","text":"Create new solution This section explains how to create a CMSIS solution-based project that is using CMSIS-Packs. In the CMSIS view, click Create a New Solution . If you already have a solution opened, use the menu ( ... ) item Create a Solution . The Create new solution dialog allows to start projects based on a Target Board or Target Device selection. Examples, templates, and reference applications depend on the selected board or device and on installed CMSIS-Packs. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These projects require the installation of related CMSIS-Packs and additional software layers for an evaluation board. Templates are stub projects that help you getting started. Some CMSIS-Packs may contain device-specific templates. The Solution Sub Folder is typically a sub-directory in your workspace. The Solution Base Folder specifies your workspace location that may contain multiple projects. With Initialize Git repository the related .gitignore file is created. Show project opening options allows you to open the spolution a new instance of VS Code. By default, the solution is loaded into the current VS Code instance. Work with examples Click the Target Board (Optional) drop-down list. Enter a search term (here: \"U5\"), and then select a board (here: \"B-U585-IOT02A\"). The details of the selected board are displayed. Click Select . Next, select the example project. There are two types of example projects: Csolution Examples are using Keil Studio's native project format. uVision Examples are in *.uvprojx format and are converted automatically. Note You may see examples from Local packs and/or from the Web . To verify the Keil Studio installation, select a Blinky project for example. Specify a Solution Base Folder and click Create . Continue to \"build the project\" . Work with reference applications Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with these CMSIS-Packs: MDK-Middleware : use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. SDS Framework : record real-world data off a device and playing it back on Arm Virtual Hardware. LiteRT : demonstrates the fundamental integration and usage of the LiteRT stack for ML inference on a microcontroller. Once you have selected the reference application, continue to \"build the project\" . Work with templates Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Continue to \"build the project\" . Project contents Once you have selected an example/template/reference application, the solution is created automatically. If a uVision example is converted, check the Output tab. Conversion errors and warnings are displayed in the CMSIS Solution category. You can also check the uv2csolution.log file. Note If you are using Keil Studio for the first time, the Arm Tools Environment Manager needs to download required tools from the Internet. While may take a couple of minutes (depending on your internet connection), it is only required once. The following files are created for the solution: A <solution_name>.csolution.yml file. One or more <project_name>.cproject.yml files, each available in a separate folder. A cdefault.yml file containing default toolchain setting for the selected toolchain. A <solution_name>.cbuild-idx.yml file which contains overall information for the application. A <solution_name>.cbuild-pack.yml file listing all the packs that are used by the application. Missing CMSIS-Packs are installed automatically. A <solution_name>.cbuild-set.yml file which specifies the context set of projects, target-types, and build-types that are used to generate the application image A <solution_name>+<target_name>.cbuild-run.yml file which contains a build description of a single cproject.yml input file for each context. A main <filename>.c template file for each project. A vcpkg-configuration.json file to download required tools automatically. Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution first. First time users may need to confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in a project. Build Before you can download the application on your target device, you need to build it. There are various ways to trigger a build: In the Explorer view , right-click the *.csolution.yml file and select Build solution . In the CMSIS view , click . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Continue to load and run the solution. Build output After you initiate the build process, a Terminal window opens and displays the build operation: Execute: cbuild /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/Blinky.csolution.yml --active NUCLEO-F756ZG --packs +--------------------------------------------------- (1/1) Building context: \"Blinky.Debug+NUCLEO-F756ZG\" Using AC6 V6.24.0 compiler, from: '/Users/user/.vcpkg/artifacts/2139c4c6/compilers.arm.armclang/6.24.0/bin/' Building CMake target 'Blinky.Debug+NUCLEO-F756ZG' [1/51] Building C object CMakeFiles/Group_Source_Files_retarget_stdio_c.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/retarget_stdio.o [2/51] Building ASM object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/MDK-ARM/startup_stm32f756xx.o Warning: A1950W: The legacy armasm assembler is deprecated. Consider using the armclang integrated assembler instead. 0 Errors, 1 Warning [3/51] Building C object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/Src/stm32f7xx_hal_timebase_tim.o ... [49/51] Building C object CMakeFiles/Keil_CMSIS_Driver_USART_3_0_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-Driver_STM32/1.1.0/Drivers/USART_STM32.o [50/51] Building C object CMakeFiles/ARM_CMSIS_RTOS2_Keil_RTX5_Source_5_9_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-RTX/5.9.0/Source/rtx_thread.o [51/51] Linking C executable /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/out/Blinky/NUCLEO-F756ZG/Debug/Blinky.axf Program Size: Code=31972 RO-data=1076 RW-data=512 ZI-data=38760 +------------------------------------------------------------ Build summary: 1 succeeded, 0 failed - Time Elapsed: 00:00:04 +============================================================ Completed: cbuild succeed with exit code 0 Build complete The output directory usually contains an ELF ( .axf ) and a HEX ( .hex ) file. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox. Load and Run Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the CMSIS view, click . This executes the \"Load & Run application\" command that flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multi-core device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. Monitoring printf messages Keil Studio includes the Serial Monitor extension that connects to the target's serial output port. If your example contains printf statements, use the Serial Monitor to observe them.","title":"Create New Solution"},{"location":"create_app.html#create-new-solution","text":"This section explains how to create a CMSIS solution-based project that is using CMSIS-Packs. In the CMSIS view, click Create a New Solution . If you already have a solution opened, use the menu ( ... ) item Create a Solution . The Create new solution dialog allows to start projects based on a Target Board or Target Device selection. Examples, templates, and reference applications depend on the selected board or device and on installed CMSIS-Packs. Examples are created for a specific hardware or evaluation board. These are typically complete projects that directly interface with board and device peripherals. Reference Applications use defined interfaces (APIs) and are therefore hardware agnostic. These projects require the installation of related CMSIS-Packs and additional software layers for an evaluation board. Templates are stub projects that help you getting started. Some CMSIS-Packs may contain device-specific templates. The Solution Sub Folder is typically a sub-directory in your workspace. The Solution Base Folder specifies your workspace location that may contain multiple projects. With Initialize Git repository the related .gitignore file is created. Show project opening options allows you to open the spolution a new instance of VS Code. By default, the solution is loaded into the current VS Code instance.","title":"Create new solution"},{"location":"create_app.html#work-with-examples","text":"Click the Target Board (Optional) drop-down list. Enter a search term (here: \"U5\"), and then select a board (here: \"B-U585-IOT02A\"). The details of the selected board are displayed. Click Select . Next, select the example project. There are two types of example projects: Csolution Examples are using Keil Studio's native project format. uVision Examples are in *.uvprojx format and are converted automatically. Note You may see examples from Local packs and/or from the Web . To verify the Keil Studio installation, select a Blinky project for example. Specify a Solution Base Folder and click Create . Continue to \"build the project\" .","title":"Work with examples"},{"location":"create_app.html#work-with-reference-applications","text":"Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with these CMSIS-Packs: MDK-Middleware : use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. SDS Framework : record real-world data off a device and playing it back on Arm Virtual Hardware. LiteRT : demonstrates the fundamental integration and usage of the LiteRT stack for ML inference on a microcontroller. Once you have selected the reference application, continue to \"build the project\" .","title":"Work with reference applications"},{"location":"create_app.html#work-with-templates","text":"Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Continue to \"build the project\" .","title":"Work with templates"},{"location":"create_app.html#project-contents","text":"Once you have selected an example/template/reference application, the solution is created automatically. If a uVision example is converted, check the Output tab. Conversion errors and warnings are displayed in the CMSIS Solution category. You can also check the uv2csolution.log file. Note If you are using Keil Studio for the first time, the Arm Tools Environment Manager needs to download required tools from the Internet. While may take a couple of minutes (depending on your internet connection), it is only required once. The following files are created for the solution: A <solution_name>.csolution.yml file. One or more <project_name>.cproject.yml files, each available in a separate folder. A cdefault.yml file containing default toolchain setting for the selected toolchain. A <solution_name>.cbuild-idx.yml file which contains overall information for the application. A <solution_name>.cbuild-pack.yml file listing all the packs that are used by the application. Missing CMSIS-Packs are installed automatically. A <solution_name>.cbuild-set.yml file which specifies the context set of projects, target-types, and build-types that are used to generate the application image A <solution_name>+<target_name>.cbuild-run.yml file which contains a build description of a single cproject.yml input file for each context. A main <filename>.c template file for each project. A vcpkg-configuration.json file to download required tools automatically. Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution first. First time users may need to confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in a project.","title":"Project contents"},{"location":"create_app.html#build","text":"Before you can download the application on your target device, you need to build it. There are various ways to trigger a build: In the Explorer view , right-click the *.csolution.yml file and select Build solution . In the CMSIS view , click . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Continue to load and run the solution.","title":"Build"},{"location":"create_app.html#build-output","text":"After you initiate the build process, a Terminal window opens and displays the build operation: Execute: cbuild /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/Blinky.csolution.yml --active NUCLEO-F756ZG --packs +--------------------------------------------------- (1/1) Building context: \"Blinky.Debug+NUCLEO-F756ZG\" Using AC6 V6.24.0 compiler, from: '/Users/user/.vcpkg/artifacts/2139c4c6/compilers.arm.armclang/6.24.0/bin/' Building CMake target 'Blinky.Debug+NUCLEO-F756ZG' [1/51] Building C object CMakeFiles/Group_Source_Files_retarget_stdio_c.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/retarget_stdio.o [2/51] Building ASM object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/MDK-ARM/startup_stm32f756xx.o Warning: A1950W: The legacy armasm assembler is deprecated. Consider using the armclang integrated assembler instead. 0 Errors, 1 Warning [3/51] Building C object CMakeFiles/Group_CubeMX.dir/Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/STM32CubeMX/NUCLEO-F756ZG/STM32CubeMX/Src/stm32f7xx_hal_timebase_tim.o ... [49/51] Building C object CMakeFiles/Keil_CMSIS_Driver_USART_3_0_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-Driver_STM32/1.1.0/Drivers/USART_STM32.o [50/51] Building C object CMakeFiles/ARM_CMSIS_RTOS2_Keil_RTX5_Source_5_9_0.dir/Users/user/.cache/arm/packs/ARM/CMSIS-RTX/5.9.0/Source/rtx_thread.o [51/51] Linking C executable /Users/user/03_work/02_Projects/ST/Nucleo-F756ZG/Blinky/out/Blinky/NUCLEO-F756ZG/Debug/Blinky.axf Program Size: Code=31972 RO-data=1076 RW-data=512 ZI-data=38760 +------------------------------------------------------------ Build summary: 1 succeeded, 0 failed - Time Elapsed: 00:00:04 +============================================================ Completed: cbuild succeed with exit code 0 Build complete The output directory usually contains an ELF ( .axf ) and a HEX ( .hex ) file. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox.","title":"Build output"},{"location":"create_app.html#load-and-run","text":"Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the CMSIS view, click . This executes the \"Load & Run application\" command that flashes the project onto the target and issues a reset to start the application. To verify that the step has run correctly, check the Terminal output: Notes When you have several solutions in one folder, VS Code ignores the tasks.json and launch.json files that you created for each solution. Instead, VS Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multi-core device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window.","title":"Load and Run"},{"location":"create_app.html#monitoring-printf-messages","text":"Keil Studio includes the Serial Monitor extension that connects to the target's serial output port. If your example contains printf statements, use the Serial Monitor to observe them.","title":"Monitoring printf messages"},{"location":"debug.html","text":"Debug the application Debugging is an essential task for every embedded developer. The CMSIS View offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features. CMSIS View The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run . Run and Debug View The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core. Debug on hardware Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and debug\" command that flashes the project onto the target and starts a debug session. Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output.","title":"Debug"},{"location":"debug.html#debug-the-application","text":"Debugging is an essential task for every embedded developer. The CMSIS View offers action buttons to start a debug session. The Run and Debug View lets you connect to the target. Refer to the Arm CMSIS Debugger extension for a detailed description of debug features.","title":"Debug the application"},{"location":"debug.html#cmsis-view","text":"The CMSIS View offers these action buttons: Load & Run a csolution application which downloads and starts the application images in the target. Load & Debug a csolution application which downloads the application images and starts the debugger. Manage Solution configures the debug setup with the target-set: node. It also supports multiple configurations using a set: name. The action button: Load & Run executes from tasks.json the command CMSIS Load+Run . Load & Debug executes from launch.json the first section with \"request\": \"launch\" and cmsis: . If this is not present it uses from tasks.json the command CMSIS Load+Debug . Further commands are available under ... : Load executes from tasks.json the command CMSIS Load . Erase executes from tasks.json the command CMSIS Erase . Run executes from tasks.json the command CMSIS Run .","title":"CMSIS View"},{"location":"debug.html#run-and-debug-view","text":"The Run and Debug View in VS Code connects to the target using the request selection shown below. The CMSIS Solution extension handles multiple processor cores using one debug connection for each core.","title":"Run and Debug View"},{"location":"debug.html#debug-on-hardware","text":"Attention Make sure that your project is set up correctly for run and debug . Make sure that your target is connected, before loading the application onto it. You can use pyOCD to verify target connectivity. Open a Terminal , and enter pyOCD list to check attached hardware: In the Solution outline header, click . This executes the \"load and debug\" command that flashes the project onto the target and starts a debug session. Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output.","title":"Debug on hardware"},{"location":"importuv.html","text":"Import a Keil \u00b5Vision project With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in VS Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored. Caveats Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see. Using Arm Compiler 5 The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide . Using dollar sign in linker misc controls In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds. Using dots in project file names In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" . Project located in paths containing a dollar sign In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign. Component mismatches when using generators Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Import uVision Project"},{"location":"importuv.html#import-a-keil-vision-project","text":"With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in VS Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored.","title":"Import a Keil \u00b5Vision project"},{"location":"importuv.html#caveats","text":"Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see.","title":"Caveats"},{"location":"importuv.html#using-arm-compiler-5","text":"The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in VS Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide .","title":"Using Arm Compiler 5"},{"location":"importuv.html#using-dollar-sign-in-linker-misc-controls","text":"In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds.","title":"Using dollar sign in linker misc controls"},{"location":"importuv.html#using-dots-in-project-file-names","text":"In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" .","title":"Using dots in project file names"},{"location":"importuv.html#project-located-in-paths-containing-a-dollar-sign","text":"In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign.","title":"Project located in paths containing a dollar sign"},{"location":"importuv.html#component-mismatches-when-using-generators","text":"Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Component mismatches when using generators"},{"location":"installation.html","text":"Installation Prerequisites As Keil Studio is a set of extensions for Microsoft Visual Studio Code , make sure this is installed on your machine. If you are using a third-party debug adapter, make sure that the latest drivers are installed on your machine: For ST-LINK support on Windows, visit STSW-LINK009 . For J-Link support, visit J-Link/J-Trace Downloads . Make sure the debug adapters are running the latest firmware and that the PATH variable is set correctly. For J-Link, you can verify the correct operation by entering the command jlink (Windows) or jlinkexe (Linux, macOS) in a Terminal window. The output should similar to this: SEGGER J-Link Commander V8.24 (Compiled Mar 26 2025 15:34:18) DLL version V8.24, compiled Mar 26 2025 15:33:37 Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. J-Link> Installing Keil Studio The Arm Keil Studio Pack (MDK v6) extension pack includes the extensions that are required to work with CMSIS solution projects. In VS Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or verify the installation with an example project and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the Arm CMSIS Solution extension standalone. Search for CMSIS Solution in the Extensions view. Verify the installation Once you have installed Keil Studio, you can verify your installation using one of the examples provided in a CMSIS-Pack. Start creating a new solution based on a Blinky example, which typically flashes an LED on a target board.","title":"Installation"},{"location":"installation.html#installation","text":"","title":"Installation"},{"location":"installation.html#prerequisites","text":"As Keil Studio is a set of extensions for Microsoft Visual Studio Code , make sure this is installed on your machine. If you are using a third-party debug adapter, make sure that the latest drivers are installed on your machine: For ST-LINK support on Windows, visit STSW-LINK009 . For J-Link support, visit J-Link/J-Trace Downloads . Make sure the debug adapters are running the latest firmware and that the PATH variable is set correctly. For J-Link, you can verify the correct operation by entering the command jlink (Windows) or jlinkexe (Linux, macOS) in a Terminal window. The output should similar to this: SEGGER J-Link Commander V8.24 (Compiled Mar 26 2025 15:34:18) DLL version V8.24, compiled Mar 26 2025 15:33:37 Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. J-Link>","title":"Prerequisites"},{"location":"installation.html#installing-keil-studio","text":"The Arm Keil Studio Pack (MDK v6) extension pack includes the extensions that are required to work with CMSIS solution projects. In VS Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or verify the installation with an example project and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the Arm CMSIS Solution extension standalone. Search for CMSIS Solution in the Extensions view.","title":"Installing Keil Studio"},{"location":"installation.html#verify-the-installation","text":"Once you have installed Keil Studio, you can verify your installation using one of the examples provided in a CMSIS-Pack. Start creating a new solution based on a Blinky example, which typically flashes an LED on a target board.","title":"Verify the installation"},{"location":"manage_components.html","text":"Manage software components A software component encapsulates a set of related functions. The Software Components view shows all the software components selected in the active project of a solution. You can: Modify the software components of the project. Manage the dependencies between components for each target type defined in your solution, or for all the target types at once. Software Components view Open the CMSIS view and click Manage software components . The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation. Modify the software components in your project You can add components from all the packs available, not just the packs that are already selected for a project. Modify the context displayed In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option. Select components Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated. Validation Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Software Components"},{"location":"manage_components.html#manage-software-components","text":"A software component encapsulates a set of related functions. The Software Components view shows all the software components selected in the active project of a solution. You can: Modify the software components of the project. Manage the dependencies between components for each target type defined in your solution, or for all the target types at once.","title":"Manage software components"},{"location":"manage_components.html#software-components-view","text":"Open the CMSIS view and click Manage software components . The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation.","title":"Software Components view"},{"location":"manage_components.html#modify-the-software-components-in-your-project","text":"You can add components from all the packs available, not just the packs that are already selected for a project.","title":"Modify the software components in your project"},{"location":"manage_components.html#modify-the-context-displayed","text":"In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option.","title":"Modify the context displayed"},{"location":"manage_components.html#select-components","text":"Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated.","title":"Select components"},{"location":"manage_components.html#validation","text":"Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Validation"},{"location":"manage_settings.html","text":"Manage Solution In the Manage Solution view, you can select the target, projects, and build types that are included in the application image. You can also specify the debug adapter that you are using for target connectivity. In the CMSIS view , click Manage Solution Settings . The Manage Solution view opens: Context Set In the Context Set section, you can change the active target type, and the active projects included in the build, as well as the build type of a project. Active Target Select a Target Type to specify the hardware used to build the solution for. To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml . Active Projects Select the project(s) that are part of the solution. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file. Errors and warnings You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense . Debug Adapter Use this drop-down to select the debug adapter that you are using for target connectivity. A broad range of adapters is supported: CMSIS-DAP Infineon KitProg3 NXP MCU-Link Nuvoton Nu-Link Microchip PICkit Segger J-Link STMicroelectronics ST-Link","title":"Manage Solution"},{"location":"manage_settings.html#manage-solution","text":"In the Manage Solution view, you can select the target, projects, and build types that are included in the application image. You can also specify the debug adapter that you are using for target connectivity. In the CMSIS view , click Manage Solution Settings . The Manage Solution view opens:","title":"Manage Solution"},{"location":"manage_settings.html#context-set","text":"In the Context Set section, you can change the active target type, and the active projects included in the build, as well as the build type of a project.","title":"Context Set"},{"location":"manage_settings.html#active-target","text":"Select a Target Type to specify the hardware used to build the solution for. To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml .","title":"Active Target"},{"location":"manage_settings.html#active-projects","text":"Select the project(s) that are part of the solution. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file.","title":"Active Projects"},{"location":"manage_settings.html#errors-and-warnings","text":"You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the VS Code documentation on IntelliSense .","title":"Errors and warnings"},{"location":"manage_settings.html#debug-adapter","text":"Use this drop-down to select the debug adapter that you are using for target connectivity. A broad range of adapters is supported: CMSIS-DAP Infineon KitProg3 NXP MCU-Link Nuvoton Nu-Link Microchip PICkit Segger J-Link STMicroelectronics ST-Link","title":"Debug Adapter"},{"location":"runexternal.html","text":"Run external tools VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases. Variables VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view. Substitution examples The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml Examples pyOCD Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] } Arm Debugger Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] } Use \u00b5Vision for debugging The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Run External Tools"},{"location":"runexternal.html#run-external-tools","text":"VS Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases.","title":"Run external tools"},{"location":"runexternal.html#variables","text":"VS Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the VS Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view.","title":"Variables"},{"location":"runexternal.html#substitution-examples","text":"The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml","title":"Substitution examples"},{"location":"runexternal.html#examples","text":"","title":"Examples"},{"location":"runexternal.html#pyocd","text":"Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] }","title":"pyOCD"},{"location":"runexternal.html#arm-debugger","text":"Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] }","title":"Arm Debugger"},{"location":"runexternal.html#use-vision-for-debugging","text":"The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in VS Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Use \u00b5Vision for debugging"},{"location":"tipsandtricks.html","text":"Tips and tricks This chapter contains useful information to help you solve specific issues. Create vcpkg configuration file If your solution does not contain the vcpkg-configuration.json , right-click anywhere in the workspace and select Configure Arm Tools Environment . The Arm Tools Environment Manager extension then generates this file. Set current solution in workspace To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions . Documentation does not open If you are using a Linux machine that uses the Snap package manager, your web browser will not be able to open documentation that is shipped in CMSIS-Packs as the CMSIS_PACK_ROOT directory is in ${HOME}/.cache/arm/packs which is not accessible to Snaps. Likewise, the Keil Studio help is located in ${HOME}/.vscode/extensions which is also not available. To get this working, use a browser that is not installed as a Snap package: Uninstall the Snap package. For example, run sudo snap remove firefox in a Terminal window. Download the installer from the browser's web site. Install it on your machine.","title":"Tips and Tricks"},{"location":"tipsandtricks.html#tips-and-tricks","text":"This chapter contains useful information to help you solve specific issues.","title":"Tips and tricks"},{"location":"tipsandtricks.html#create-vcpkg-configuration-file","text":"If your solution does not contain the vcpkg-configuration.json , right-click anywhere in the workspace and select Configure Arm Tools Environment . The Arm Tools Environment Manager extension then generates this file.","title":"Create vcpkg configuration file"},{"location":"tipsandtricks.html#set-current-solution-in-workspace","text":"To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions .","title":"Set current solution in workspace"},{"location":"tipsandtricks.html#documentation-does-not-open","text":"If you are using a Linux machine that uses the Snap package manager, your web browser will not be able to open documentation that is shipped in CMSIS-Packs as the CMSIS_PACK_ROOT directory is in ${HOME}/.cache/arm/packs which is not accessible to Snaps. Likewise, the Keil Studio help is located in ${HOME}/.vscode/extensions which is also not available. To get this working, use a browser that is not installed as a Snap package: Uninstall the Snap package. For example, run sudo snap remove firefox in a Terminal window. Download the installer from the browser's web site. Install it on your machine.","title":"Documentation does not open"},{"location":"userinterface.html","text":"User Interface The CMSIS Solution extension provides the Keil Studio GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment. Overview The GUI consists of these elements: 1. Dedicated views from the side bar Explorer view lists all local files of the CMSIS solution. Search view enables searching all files of the CMSIS solution Source Control view allows you to work with git. Extensions view lets you work with VS Code extensions. Run and Debug view switches the GUI to a dedicated debug view . CMSIS view is the main view for working with CMSIS solution-based projects. Note The ordering of the icons may be different in your VS Code environment. 2. Main area of the CMSIS view The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The main area of the CMSIS view shows: Board and device information and related documentation. Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files 3. Icons available through the CMSIS view Build solution calls the compiler toolchain and builds the CMSIS solution. Load & Run application flashes the binary onto the target and starts the application. Load & Debug application flashes the binary onto the target and starts a debug session. Open csolution.yml file opens the CMSIS solution YML file for editing. Manage Solution Settings allows you to manage the CMSIS solution settings. shows further views and more actions. 4. Main area icons Depending on the file and the context, various icons may appear: IntelliSense is active for this cproject file. Open the file. Manage the software components of the cproject file. Add groups or files to the cproject file. 5. Status bar The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Status message of the clangd extension (used for IntelliSense). You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it. Available commands You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view. When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution","title":"User Interface"},{"location":"userinterface.html#user-interface","text":"The CMSIS Solution extension provides the Keil Studio GUI for project management and build tools with the CMSIS-Toolbox . Combined with other Arm and third-party extensions, it implements a powerful embedded development environment.","title":"User Interface"},{"location":"userinterface.html#overview","text":"The GUI consists of these elements:","title":"Overview"},{"location":"userinterface.html#1-dedicated-views-from-the-side-bar","text":"Explorer view lists all local files of the CMSIS solution. Search view enables searching all files of the CMSIS solution Source Control view allows you to work with git. Extensions view lets you work with VS Code extensions. Run and Debug view switches the GUI to a dedicated debug view . CMSIS view is the main view for working with CMSIS solution-based projects. Note The ordering of the icons may be different in your VS Code environment.","title":"1. Dedicated views from the side bar"},{"location":"userinterface.html#2-main-area-of-the-cmsis-view","text":"The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The main area of the CMSIS view shows: Board and device information and related documentation. Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files","title":"2. Main area of the CMSIS view"},{"location":"userinterface.html#3-icons-available-through-the-cmsis-view","text":"Build solution calls the compiler toolchain and builds the CMSIS solution. Load & Run application flashes the binary onto the target and starts the application. Load & Debug application flashes the binary onto the target and starts a debug session. Open csolution.yml file opens the CMSIS solution YML file for editing. Manage Solution Settings allows you to manage the CMSIS solution settings. shows further views and more actions.","title":"3. Icons available through the CMSIS view"},{"location":"userinterface.html#4-main-area-icons","text":"Depending on the file and the context, various icons may appear: IntelliSense is active for this cproject file. Open the file. Manage the software components of the cproject file. Add groups or files to the cproject file.","title":"4. Main area icons"},{"location":"userinterface.html#5-status-bar","text":"The VS Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Status message of the clangd extension (used for IntelliSense). You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"5. Status bar"},{"location":"userinterface.html#available-commands","text":"You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view. When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Create a Solution Create a new csolution project . Configure Solution Set a compiler and add software layers Manage Solution Settings Configure the build context and debug setup. Manage Software Components Review, add, or remove software components Run Configuration Generator Open a configuration tools such as CubeMX Build solution Build the solution with the current context set Rebuild solution Rebuild the solution with the current context set Debug Debug the solution with the current context set Run Run the solution on your target Focus on Solution View Open the CMSIS view Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to csolution project format Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Clean all out and tmp directories Clean all out and tmp directories for the active solution","title":"Available commands"}]}