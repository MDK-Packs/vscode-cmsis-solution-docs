{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CMSIS Solution extension The CMSIS Solution extension available in Visual Studio Code provides tools to create projects and build embedded applications that use software packs . Various compilation tools are supported. Contents Setup explains how to install the CMSIS Solution extension along with a build environment for embedded applications that are based on Arm Cortex-M processors Quick start shows the main features available in the CMSIS Solution extension GUI Create an embedded project explains how to start a project from scratch Manage software components shows how to add or remove software components in a solution Set a context shows how to set the context of a solution Build a project describes how to build a project Run the application explains how to run an application on your hardware Debug a project explains how to debug a project Configuration explains how to manage the extension settings and some specific configuration options Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format Run external tools describes how to use external tools, such as debuggers and flash programmers Tips and tricks provides tips and tricks to help you solve specific issues Revision history Version Description 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Home"},{"location":"index.html#cmsis-solution-extension","text":"The CMSIS Solution extension available in Visual Studio Code provides tools to create projects and build embedded applications that use software packs . Various compilation tools are supported.","title":"CMSIS Solution extension"},{"location":"index.html#contents","text":"Setup explains how to install the CMSIS Solution extension along with a build environment for embedded applications that are based on Arm Cortex-M processors Quick start shows the main features available in the CMSIS Solution extension GUI Create an embedded project explains how to start a project from scratch Manage software components shows how to add or remove software components in a solution Set a context shows how to set the context of a solution Build a project describes how to build a project Run the application explains how to run an application on your hardware Debug a project explains how to debug a project Configuration explains how to manage the extension settings and some specific configuration options Import \u00b5Vision project explains how to convert uvprojx-based files to the CMSIS Solution format Run external tools describes how to use external tools, such as debuggers and flash programmers Tips and tricks provides tips and tricks to help you solve specific issues","title":"Contents"},{"location":"index.html#revision-history","text":"Version Description 1.48.0 Initial release for the CMSIS Solution extension version 1.48.0","title":"Revision history"},{"location":"build.html","text":"Build a project Before you can download the application on your target device, you need to build it. There are various ways to trigger a build. From the Explorer view In the Explorer view , right-click the *.csolution.yml file and select Build solution . These options are also available in the right-click menu: Rebuild solution : Cleans the output directories before building the cproject Clean all out and tmp directories : Cleans the output and tmp directories for the active solution From the CMSIS view In the header, click . The Clean all out and tmp directories and Rebuild solution options are also available with . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details. Build output After you initiate the build process, a Terminal window opens and displays the build operation: Check the output to find where the ELF file ( .axf ) was generated. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox.","title":"Build a project"},{"location":"build.html#build-a-project","text":"Before you can download the application on your target device, you need to build it. There are various ways to trigger a build.","title":"Build a project"},{"location":"build.html#from-the-explorer-view","text":"In the Explorer view , right-click the *.csolution.yml file and select Build solution . These options are also available in the right-click menu: Rebuild solution : Cleans the output directories before building the cproject Clean all out and tmp directories : Cleans the output and tmp directories for the active solution","title":"From the Explorer view"},{"location":"build.html#from-the-cmsis-view","text":"In the header, click . The Clean all out and tmp directories and Rebuild solution options are also available with . You can configure a build task in a tasks.json file to customize the behavior of the build button. All the examples on keil.arm.com include a tasks.json file. See Configure a build task for more details.","title":"From the CMSIS view"},{"location":"build.html#build-output","text":"After you initiate the build process, a Terminal window opens and displays the build operation: Check the output to find where the ELF file ( .axf ) was generated. Note If the build fails with an ENOENT error, follow the instructions in the pop-up message that displays in the bottom right-hand corner to install CMSIS-Toolbox.","title":"Build output"},{"location":"configuration.html","text":"Configuration Configure the extension Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used. Configure a solution If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file. Configure a build task In Visual Studio Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks.","title":"Configuration"},{"location":"configuration.html#configuration","text":"","title":"Configuration"},{"location":"configuration.html#configure-the-extension","text":"Press Ctrl+, (Windows and Linux) or Cmd+, (macOS) or go to at the bottom of the Activity Bar and select Settings . Then, select CMSIS Solution to change the extension settings. The available settings are: Setting Description Actions Set run and debug configurations for your solutions and projects. Download Packs CMSIS-Toolbox downloads required software packs using cpackget during setup and project build. This option enables the option --packs for cbuild . Exclude Configure a glob pattern for excluding files and folders in searches for csolution files. Experimental Features Use the checkbox to enable experimental features. Generate Clang Setup Use the checkbox to automatically generate the required setup ( .clangd file and .vscode/settings.json ) for the active solution context. For Arm Compiler 6, include pre-defined macros in the .clangd file. Output Directory Enter an output directory prefix for 'outdir' and 'tmpdir' and relocated build information files (experimental). Use Web Services Use the checkbox to enable web services to obtain information about devices, boards, and examples. If enabled, information from the internet and locally installed packs is used. If disabled, only information from installed packs is used.","title":"Configure the extension"},{"location":"configuration.html#configure-a-solution","text":"If you have not already set a compiler, select a compiler for your solution from the Configure Solution view. If you created a reference application from a reference example, you can also add layers to your solution from the same view. If your project has a select-compiler: node, but no compiler: node is set in the csolution.yml file, or if your reference application has no layers defined, then the Configure Solution view opens automatically. If you are working with a reference application, Add Software Layer displays, showing the software layers that you can use. Layers are available from the CMSIS-Packs installed on your machine. Note Not all Board Support Packs (BSPs) have board layers. Not all layers are compatible with the connections that your reference application requires. The CMSIS-Packs which contain reference applications and layers generally provide an Overview.md file where the connections are detailed. If there are no compatible layers, errors display. Click Next to display the different options available. You can indicate where the layers should be copied to in the Board-Layer , Shield-Layer , and Socket-Layer fields. Click Default to reset the paths to their default values. If no compiler is set for the reference application, Select Compiler displays under the layers selection and shows the compilers available in your environment. Select a compiler. For example, AC6 or GCC. If you are working with another solution type, only Select Compiler displays. Select a compiler. Click OK . For reference applications only, a Board.clayer.yml file, a Shield.clayer.yml file, or a Socket.clayer.yml file, along with other files that make up the layer, are added in the folders that you selected. The files are available from the Explorer view. The .clayer.yml files come from the CMSIS-Pack. Layers are automatically added in the csolution.yml file of your solution under target-types: variables: for the active target. For all solution types, the compiler is added with the compiler: key in the csolution.yml file.","title":"Configure a solution"},{"location":"configuration.html#configure-a-build-task","text":"In Visual Studio Code, you can automate certain tasks by configuring a tasks.json file. See Integrate with External Tools via Tasks for more details. With the CMSIS Solution extension, you can configure a build task using the tasks.json file to build your projects. When you run the build task, the extension runs cbuild with the options that you defined. Note The examples on keil.arm.com include a tasks.json file that already contains some configuration settings to build your project. You can modify the default configuration if needed. If you are working with an example that does not have a build task configured, follow these steps: Go to Terminal > Configure Tasks... . In the drop-down list that opens at the top of the window, select the CMSIS Build task. A tasks.json file opens with the default configuration. Modify the configuration. With IntelliSense, you can see the full set of task properties and values available in the tasks.json file. You can bring up suggestions using Trigger Suggest from the Command Palette . You can also display the task properties specific to cbuild by typing cbuild --help in the Terminal . Save the tasks.json file. Alternatively, you can define a default build task using Terminal > Configure Default Build Task... . The Terminal > Run Build Task... option triggers the execution of default build tasks.","title":"Configure a build task"},{"location":"create_app.html","text":"Create an embedded project This chapter explains how to create a CMSIS solution-based application. Create a new solution In the CMSIS view, click Create a New Solution to open the Create Solution view. Note If you already have a solution opened in your workspace and want to create a new one in the same workspace, move your cursor over the three dots ... in the CMSIS view, then click Create a Solution . Click the Target Board drop-down list. Enter a search term, and then select a board. The details of the board that you selected display. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Note Alternatively, you can directly select a device in the Target Device drop-down list, without selecting a board first. Select a template, a reference application, or an example Select one of the following options from the drop-down list. The options available depend on the board or device selected previously. If there are too many examples, enter a search term and then select an example. Templates Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones Reference applications Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with the MDK-Middleware . These examples show you how to use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. See MDK Middleware Reference Applications and the MDK-Middleware repository and documentation for more details. Other reference applications that illustrate how to match sensor shields and boards are also available with the Sensor SDK pack. The examples use board and shield layers. See Sensor Reference Applications and the Sensor-SDK-Example repository for more details. Reference applications that use socket layers are also available. See the AWS MQTT demo as an example. Csolution examples CMSIS solution examples are targeted at a specific board or Fixed Virtual Platform (FVP) model. The examples are fully configured and ready for use. \u00b5Vision examples Use a \u00b5Vision example in *.uvprojx format as a starting point. \u00b5Vision examples are converted automatically. Project name After you have selected your solution template, specify a Project Name . If you selected Blank solution or TrustZone solution , one project for each processor is automatically added (for TrustZone, a secure and a non-secure project are added for each processor). You can: Change the project names Remove projects Decide to add secure or non-secure zones with the TrustZone drop-down list if the board or device is compatible. By default, TrustZone is off . Click Add Project to add projects to your solution and configure them. For TrustZone, you can add as many secure or non-secure projects as you need for a particular processor. Solution name If you selected Blank solution or TrustZone solution , you can change the name for your solution in the Solution Name field. This information is used as the <solution_name>.csolution.yml file name. Solution subfolder In the Solution Sub Folder field, you can change the name of the subfolder where the solution files are stored. Solution base folder Click Browse next to the Solution Base Folder field and choose where to store the solution subfolder using the system dialog box. With the Initialize Git repository checkbox, you can initialize the solution as a Git repository. Clear the checkbox if you do not want to turn your solution into a Git repository. Select the Show project opening options checkbox to decide where to open the solution. Click Create . The extension creates the solution and automatically converts examples that are available only in *.uvprojx format. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. Missing CMSIS-Packs are installed automatically. The following files are created for the solution: A <solution_name>.csolution.yml file One or more <project_name>.cproject.yml files, each available in a separate folder For reference applications only, each cproject.yml file contains a $Board-Layer$ variable For reference applications with sensor shields, each cproject.yml file contains a $Shield-Layer$ variable For reference applications with a socket layer, each cproject.yml file contains a $Socket-Layer$ variable. These variables are not yet defined. A main <filename>.c template file for each project A vcpkg-configuration.json file to download required tools automatically Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution before you can build the project.","title":"Create an embedded project"},{"location":"create_app.html#create-an-embedded-project","text":"This chapter explains how to create a CMSIS solution-based application.","title":"Create an embedded project"},{"location":"create_app.html#create-a-new-solution","text":"In the CMSIS view, click Create a New Solution to open the Create Solution view. Note If you already have a solution opened in your workspace and want to create a new one in the same workspace, move your cursor over the three dots ... in the CMSIS view, then click Create a Solution . Click the Target Board drop-down list. Enter a search term, and then select a board. The details of the board that you selected display. Click Select . By default, the Target Device drop-down list shows the name of the device mounted on the board that you selected. Note Alternatively, you can directly select a device in the Target Device drop-down list, without selecting a board first.","title":"Create a new solution"},{"location":"create_app.html#select-a-template-a-reference-application-or-an-example","text":"Select one of the following options from the drop-down list. The options available depend on the board or device selected previously. If there are too many examples, enter a search term and then select an example.","title":"Select a template, a reference application, or an example"},{"location":"create_app.html#templates","text":"Templates help you to get started without application-specific code. Blank solution : Start a project from scratch with an empty main.c file and the CMSIS device startup component selected TrustZone solution : If the board or device that you selected is compatible, you can use TrustZone and define whether projects in the solution use secure or non-secure zones","title":"Templates"},{"location":"create_app.html#reference-applications","text":"Reference applications show the usage of middleware, software libraries, and custom code that can run on many different target hardware boards. Examples display only if you selected a board and a software layer is available for that board. Reference applications are not dependent on specific hardware. You can deploy them to various evaluation boards using additional software layers that provide driver APIs for specific target hardware. Layers are provided using CMSIS-Packs. Reference applications are available with the MDK-Middleware . These examples show you how to use software components for IPv4 and IPv6 networking, USB Host and Device communication, and file system for data storage. See MDK Middleware Reference Applications and the MDK-Middleware repository and documentation for more details. Other reference applications that illustrate how to match sensor shields and boards are also available with the Sensor SDK pack. The examples use board and shield layers. See Sensor Reference Applications and the Sensor-SDK-Example repository for more details. Reference applications that use socket layers are also available. See the AWS MQTT demo as an example.","title":"Reference applications"},{"location":"create_app.html#csolution-examples","text":"CMSIS solution examples are targeted at a specific board or Fixed Virtual Platform (FVP) model. The examples are fully configured and ready for use.","title":"Csolution examples"},{"location":"create_app.html#vision-examples","text":"Use a \u00b5Vision example in *.uvprojx format as a starting point. \u00b5Vision examples are converted automatically.","title":"\u00b5Vision examples"},{"location":"create_app.html#project-name","text":"After you have selected your solution template, specify a Project Name . If you selected Blank solution or TrustZone solution , one project for each processor is automatically added (for TrustZone, a secure and a non-secure project are added for each processor). You can: Change the project names Remove projects Decide to add secure or non-secure zones with the TrustZone drop-down list if the board or device is compatible. By default, TrustZone is off . Click Add Project to add projects to your solution and configure them. For TrustZone, you can add as many secure or non-secure projects as you need for a particular processor.","title":"Project name"},{"location":"create_app.html#solution-name","text":"If you selected Blank solution or TrustZone solution , you can change the name for your solution in the Solution Name field. This information is used as the <solution_name>.csolution.yml file name.","title":"Solution name"},{"location":"create_app.html#solution-subfolder","text":"In the Solution Sub Folder field, you can change the name of the subfolder where the solution files are stored.","title":"Solution subfolder"},{"location":"create_app.html#solution-base-folder","text":"Click Browse next to the Solution Base Folder field and choose where to store the solution subfolder using the system dialog box. With the Initialize Git repository checkbox, you can initialize the solution as a Git repository. Clear the checkbox if you do not want to turn your solution into a Git repository. Select the Show project opening options checkbox to decide where to open the solution. Click Create . The extension creates the solution and automatically converts examples that are available only in *.uvprojx format. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. Missing CMSIS-Packs are installed automatically. The following files are created for the solution: A <solution_name>.csolution.yml file One or more <project_name>.cproject.yml files, each available in a separate folder For reference applications only, each cproject.yml file contains a $Board-Layer$ variable For reference applications with sensor shields, each cproject.yml file contains a $Shield-Layer$ variable For reference applications with a socket layer, each cproject.yml file contains a $Socket-Layer$ variable. These variables are not yet defined. A main <filename>.c template file for each project A vcpkg-configuration.json file to download required tools automatically Caution If you see this warning: Click Show output to configure the solution. You can add board, shield, or socket layers to your reference application. You can also select a compiler for reference applications and other solution types. Depending on the selected example, you might need to configure the solution before you can build the project.","title":"Solution base folder"},{"location":"debug.html","text":"Debug the application Debugging is an essential task for every embedded developer. You can debug your code on real hardware or on simulation models based on Fixed Virtual Platforms (FVPs). Debug on real hardware Check that your device is connected to your computer. To start a debug session, click in the Activity Bar . Select a debug configuration in the list . Click . Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output. Debug with simulation models FVPs are complete simulations of an Arm system, including a processor, memory, and peripherals. These are set out in a \"programmer's view\" that gives you a comprehensive model on which to build and test your software. Note FVPs are natively available on Windows and Linux only. If you are on a Mac, follow this Learning Path to install Docker and clone the FVPs-on-Mac repository. Go to the Device Manager and select the FVP that you want to use. For example, MPS2 Cortex M4 . To start a debug session, click and select the Arm Debugger FVP debug configuration in the list. Click . Troubleshooting If the Arm Debugger engine cannot be found on your machine, a dialog box displays: Select one of these options: To add Arm Debugger to your environment, click Install Arm Debugger . The vcpkg-configuration.json file is updated. To indicate the path to the Arm Debugger engine in the settings, click Configure Path .","title":"Debug a project"},{"location":"debug.html#debug-the-application","text":"Debugging is an essential task for every embedded developer. You can debug your code on real hardware or on simulation models based on Fixed Virtual Platforms (FVPs).","title":"Debug the application"},{"location":"debug.html#debug-on-real-hardware","text":"Check that your device is connected to your computer. To start a debug session, click in the Activity Bar . Select a debug configuration in the list . Click . Note If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. The Run and Debug view displays and the debug session starts. The debugger stops at the main() function of the program: The Debug Console tab displays the debugging output.","title":"Debug on real hardware"},{"location":"debug.html#debug-with-simulation-models","text":"FVPs are complete simulations of an Arm system, including a processor, memory, and peripherals. These are set out in a \"programmer's view\" that gives you a comprehensive model on which to build and test your software. Note FVPs are natively available on Windows and Linux only. If you are on a Mac, follow this Learning Path to install Docker and clone the FVPs-on-Mac repository. Go to the Device Manager and select the FVP that you want to use. For example, MPS2 Cortex M4 . To start a debug session, click and select the Arm Debugger FVP debug configuration in the list. Click .","title":"Debug with simulation models"},{"location":"debug.html#troubleshooting","text":"If the Arm Debugger engine cannot be found on your machine, a dialog box displays: Select one of these options: To add Arm Debugger to your environment, click Install Arm Debugger . The vcpkg-configuration.json file is updated. To indicate the path to the Arm Debugger engine in the settings, click Configure Path .","title":"Troubleshooting"},{"location":"flash.html","text":"Run the application Caution First, check that your hardware is connected to your computer. Before you can start debugging the application, you must download it to the flash of the target hardware. Notes When you have several solutions in one folder, Visual Studio Code ignores the tasks.json and launch.json files that you created for each solution. Instead, Visual Studio Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. In the Solution outline header, click . To verify that the project has run correctly, check the Terminal tab: Troubleshooting If the Arm Debugger engine cannot be found on your machine, a dialog box displays: Select one of these options: To add Arm Debugger to your environment, click Install Arm Debugger . The vcpkg-configuration.json file is updated. To indicate the path to the Arm Debugger engine from the settings, click Configure Path .","title":"Flash the application"},{"location":"flash.html#run-the-application","text":"Caution First, check that your hardware is connected to your computer. Before you can start debugging the application, you must download it to the flash of the target hardware. Notes When you have several solutions in one folder, Visual Studio Code ignores the tasks.json and launch.json files that you created for each solution. Instead, Visual Studio Code generates new JSON files at the root of the workspace in a .vscode folder and ignores the other JSON files. As a workaround, open one solution first, then add other solutions to your workspace with the File > Add Folder to Workspace option. If you are using a multicore device and you did not specify a \"processorName\" in the launch.json file, select the appropriate processor for your project in the Select a processor drop-down list at the top of the window. In the Solution outline header, click . To verify that the project has run correctly, check the Terminal tab:","title":"Run the application"},{"location":"flash.html#troubleshooting","text":"If the Arm Debugger engine cannot be found on your machine, a dialog box displays: Select one of these options: To add Arm Debugger to your environment, click Install Arm Debugger . The vcpkg-configuration.json file is updated. To indicate the path to the Arm Debugger engine from the settings, click Configure Path .","title":"Troubleshooting"},{"location":"importuv.html","text":"Import a Keil \u00b5Vision project With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in Visual Studio Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored. Caveats Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see. Using Arm Compiler 5 The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in Visual Studio Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide . Using dollar sign in linker misc controls In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds. Using dots in project file names In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" . Project located in paths containing a dollar sign In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign. Component mismatches when using generators Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Import uVision project"},{"location":"importuv.html#import-a-keil-vision-project","text":"With the CMSIS Solution extension, you can convert a Keil \u03bcVision project to a CMSIS solution. Open the folder that contains the *.uvprojx that you want to convert in Visual Studio Code. Alternatively, import a \u03bcVision project from keil.arm.com , or clone a project from GitHub. Do one of the following: From the Explorer view, right-click the *.uvprojx file and select Convert \u03bcVision project to CMSIS solution . Alternatively, if you are starting from an empty workspace, you can click in the Activity Bar to open the CMSIS view. Then choose one of the following options: Click Convert a \u03bcVision Project to CMSIS Solution and open your *.uvprojx file to convert it. Click Views and More Actions , then select Convert \u03bcVision project to CMSIS solution and open your *.uvprojx file to convert it. A dialog box displays. You can carry out the following tasks: - Open the solution in a new workspace with the **Open** option. - Open the solution in a new window and new workspace with the **Open project in new window** option. You can also run the CMSIS: Convert \u03bcVision project to CMSIS solution command from the Command Palette. In that case, select the *.uvprojx that you want to convert on your machine and click Select. If a *.csolution.yml file already exists in the same folder as the *.uvprojx file , then a pop-up message displays in the bottom right-hand corner. Click Overwrite to overwrite the existing file. The conversion starts immediately. Confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in your vcpkg-configuration.json file. Check the Output tab. If there are any conversion errors and warnings, they display in the CMSIS Solution category. You can also check the uv2csolution.log file. The *.cproject.yml and *.csolution.yml files are available in the folder where the *.uvprojx is stored.","title":"Import a Keil \u00b5Vision project"},{"location":"importuv.html#caveats","text":"Depending on how your \u00b5Vision project is written, the conversion may encounter problems. The following is a (non-exhaustive) list of issues you might see.","title":"Caveats"},{"location":"importuv.html#using-arm-compiler-5","text":"The conversion does not work with Arm Compiler 5-based projects. Only projects using Arm Compiler 6 can be converted. Workaround Update an Arm Compiler 5 project to Arm Compiler 6 in Keil \u03bcVision, then convert the project to a CMSIS solution in Visual Studio Code. Note For more information, see the Migrate Arm Compiler 5 to Arm Compiler 6 application note and the Arm Compiler for Embedded Migration and Compatibility Guide .","title":"Using Arm Compiler 5"},{"location":"importuv.html#using-dollar-sign-in-linker-misc-controls","text":"In \u00b5Vision, you can use the dollar sign ( $ ) for Linker misc options in the Options for Target dialog: Attention Using this will cause a malformed YML access sequence in the generated cproject.yml file that will fail subsequent builds.","title":"Using dollar sign in linker misc controls"},{"location":"importuv.html#using-dots-in-project-file-names","text":"In \u00b5Vision project names, you can use the dot, e.g. MyProjeckt_1.0.vuprojx. In CMSIS solution project format, dots are used to separate project names, build type, and target types (refer to Context ). Attention Using dots in project names will lead to \"error csolution: schema check failed, verify syntax\" .","title":"Using dots in project file names"},{"location":"importuv.html#project-located-in-paths-containing-a-dollar-sign","text":"In some operating systems, paths can contain the dollar ( $ ) sign. Try avoiding the $ sing in path names as this will cause build to fail. A workaround is available (see below). Attention Building the project will fail with a similar message: error csolution: malformed access sequence: '/$test/Blinky_FRDM-K32L3A6 Workaround Use the -O option to redirect all output to a directory without the $ sign.","title":"Project located in paths containing a dollar sign"},{"location":"importuv.html#component-mismatches-when-using-generators","text":"Older projects using GPDSC-based generators will see an issue after the conversion. In the original uvprojx file, an entry for STM32CubeMX could look like this: <component Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.1.0\" condition=\"STCubeMX\" generated=\"1\" generator=\"STM32CubeMX\"> <package name=\"FrameworkCubeMX\" schemaVersion=\"1.0\" url=\"project-path\" vendor=\"Keil\" version=\"1.0.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Modern DFPs with generator support would look like: <component Capiversion=\"1.0.0\" Cclass=\"Device\" Cgroup=\"STM32Cube Framework\" Csub=\"STM32CubeMX\" Cvendor=\"Keil\" Cversion=\"1.0.0\" condition=\"STM32H7_SC\" generator=\"STM32CubeMX\"> <package name=\"STM32H7xx_DFP\" schemaVersion=\"1.6.3\" url=\"http://www.keil.com/pack/\" vendor=\"Keil\" version=\"2.7.0\"/> <targetInfos> <targetInfo name=\"nucleo\"/> </targetInfos> </component> Attention uv2csolution adds a non-existing pack node Keil::FrameworkCubeMX@^1.0.0 which will lead to an error like this: error csolution: required pack: Keil::FrameworkCubeMX@^1.0.0 not installed Workaround Delete the corresponding line from the cproject.yml file.","title":"Component mismatches when using generators"},{"location":"installation.html","text":"Setup The Arm Keil Studio Pack (MDK v6) extension pack includes the CMSIS Solution extension and other extensions that you can use to work with CMSIS solution projects. In Visual Studio Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or download an example project and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the CMSIS Solution extension as standalone. Search for CMSIS Solution in the Extensions view. Find an example project The CMSIS boards list contains many examples that you can use to verify that the extension works correctly. The following procedure explains how to start from an example for the NXP FRDM-K32L3A6 development board . Adapt the steps to your development board. In your browser, open the CMSIS boards list . In the search bar, type frdm-k32 . Alternatively, you can search for a board using the Vendor and Core filters. In the list of suggested boards, click FRDM-K32L3A6 . The board page opens on the Projects tab. This tab shows the list of available example projects. In the search bar, type hello_frdm . In the Get Project drop-down list, select Open in Keil Studio for VS Code to download the example to your computer and open it in Visual Studio Code. Visual Studio Code asks for a permission to open the URI. Click Open . Select a download location. Select Open in New Window to open the example in a separate Visual Studio Code window. If you installed the Keil Studio Pack, confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in your project. You can now build and debug the example project.","title":"Setup"},{"location":"installation.html#setup","text":"The Arm Keil Studio Pack (MDK v6) extension pack includes the CMSIS Solution extension and other extensions that you can use to work with CMSIS solution projects. In Visual Studio Code, open the Extensions view and type Keil Studio Pack in the search bar. Click Install to start the installation. When the installation is finished, the CMSIS view icon appears in the activity bar. You can create your first application or download an example project and then check that you can build, run, and debug the application. Note If you do not want to install all the extensions available in the pack, you can install the CMSIS Solution extension as standalone. Search for CMSIS Solution in the Extensions view.","title":"Setup"},{"location":"installation.html#find-an-example-project","text":"The CMSIS boards list contains many examples that you can use to verify that the extension works correctly. The following procedure explains how to start from an example for the NXP FRDM-K32L3A6 development board . Adapt the steps to your development board. In your browser, open the CMSIS boards list . In the search bar, type frdm-k32 . Alternatively, you can search for a board using the Vendor and Core filters. In the list of suggested boards, click FRDM-K32L3A6 . The board page opens on the Projects tab. This tab shows the list of available example projects. In the search bar, type hello_frdm . In the Get Project drop-down list, select Open in Keil Studio for VS Code to download the example to your computer and open it in Visual Studio Code. Visual Studio Code asks for a permission to open the URI. Click Open . Select a download location. Select Open in New Window to open the example in a separate Visual Studio Code window. If you installed the Keil Studio Pack, confirm that the Arm Tools Environment Manager extension can automatically activate the workspace and download the tools specified in the vcpkg-configuration.json file included in your project. You can now build and debug the example project.","title":"Find an example project"},{"location":"manage_components.html","text":"Manage software components The Software Components view shows all the software components selected in the active project of a solution. You can do the following: Modify the software components of the project Manage the dependencies between components for each target type defined in your solution, or for all the target types at once Software Components view Open the CMSIS view . In the Solution outline , click Manage software components at the project level. The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation. Modify the software components in your project You can add components from all the packs available, not just the packs that are already selected for a project. Modify the context displayed In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option. Select components Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated. Validation Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Manage software components"},{"location":"manage_components.html#manage-software-components","text":"The Software Components view shows all the software components selected in the active project of a solution. You can do the following: Modify the software components of the project Manage the dependencies between components for each target type defined in your solution, or for all the target types at once","title":"Manage software components"},{"location":"manage_components.html#software-components-view","text":"Open the CMSIS view . In the Solution outline , click Manage software components at the project level. The Software Components view opens: The default view displays the components available from the packs listed in your solution. Use the Search field to search the list of components. Layer icons indicate which components are used in layers. In the current version, layers are read-only, so you cannot select or clear them. Click the layer icon of a component to open the *.clayer.yml file or associated files. Learn more links are available for some components. Click the links to open the related documentation.","title":"Software Components view"},{"location":"manage_components.html#modify-the-software-components-in-your-project","text":"You can add components from all the packs available, not just the packs that are already selected for a project.","title":"Modify the software components in your project"},{"location":"manage_components.html#modify-the-context-displayed","text":"In the Project drop-down list, select the project for which you want to modify software components. In the Target drop-down list, select a specific target type. If you want to modify all the target types at once, select All Targets . Note that you might have only one target. In the Software packs drop-down list, you can filter on the components available from the packs listed in your solution with the Solution: <Solution-name> option. You can display the components from all installed packs with the All installed packs option.","title":"Modify the context displayed"},{"location":"manage_components.html#select-components","text":"Check that the All toggle button is selected to display all the components available. Switch to Selected to display only the components that are already selected. Use the checkboxes to select or clear components as required. For some components, you can also select a vendor, variant, or version. The cproject.yml file is automatically updated.","title":"Select components"},{"location":"manage_components.html#validation","text":"Manage the dependencies between components and solve validation issues from the Validation panel. Issues are highlighted in red and have an exclamation mark icon next to them. You can remove conflicting components from your selection or add missing component dependencies from a suggested list. If there are validation issues, move your cursor over the issues in the Validation panel to get more details. Click the proposed fixes to find the components in the list. In some cases, you might have to choose between different fix sets. Select a fix set in the drop-down list, make the required component choices, and then click Apply . If a pack is missing in the solution, a Component's pack is not included in your solution message displays in the Validation panel. An error also displays in the Problems view. Install the pack with the cpackget command. There can also be issues such as: A component that you selected is incompatible with the selected hardware and toolchain A component that you selected has dependencies which are incompatible with the selected hardware and toolchain A component that you selected has unresolvable dependencies In such cases, you must remove the component. Click Apply from the Validation panel.","title":"Validation"},{"location":"manage_settings.html","text":"Set a context In the Manage Solution view, you can set the context of your solution. The context set selects the target and defines the projects and build types that are included in the application image. In the Solution outline , click Manage Solution Settings . The Manage Solutions view opens: You can change the active target type, and the active projects included in the build. You can also change the build type of a project, or the run and debug configurations, or you can add new configurations. Active target Select a Target Type to specify the hardware used to build the solution. Some examples are also compatible with Arm Virtual Hardware (AVH) targets, in which case more options are available. For more details, read the AVH solutions overview . To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml . Active projects This section shows the projects that are part of the solution. Use the checkboxes to add or remove projects from the context set. The Project Name displays and cannot be changed. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. YAML syntax support helps you with editing. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file. Run and debug Choose a run configuration and a debug configuration to use for your solution. You can select different run and debug configurations for each project included in the solution. You can also move your mouse over an entry in the list and click the pen icon to edit an existing configuration with a visual editor: Click + Add new to add a new configuration. Errors and warnings You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the Visual Studio Code documentation on IntelliSense .","title":"Manage settings"},{"location":"manage_settings.html#set-a-context","text":"In the Manage Solution view, you can set the context of your solution. The context set selects the target and defines the projects and build types that are included in the application image. In the Solution outline , click Manage Solution Settings . The Manage Solutions view opens: You can change the active target type, and the active projects included in the build. You can also change the build type of a project, or the run and debug configurations, or you can add new configurations.","title":"Set a context"},{"location":"manage_settings.html#active-target","text":"Select a Target Type to specify the hardware used to build the solution. Some examples are also compatible with Arm Virtual Hardware (AVH) targets, in which case more options are available. For more details, read the AVH solutions overview . To specify your target types by editing the YAML file directly, click Edit targets, build-types and project references in csolution.yml .","title":"Active target"},{"location":"manage_settings.html#active-projects","text":"This section shows the projects that are part of the solution. Use the checkboxes to add or remove projects from the context set. The Project Name displays and cannot be changed. Select a Build Type for each project. You can set different build types for different projects in your solution. Click Edit cproject.yml next to a project to open the <project-name>.cproject.yml file. YAML syntax support helps you with editing. Note The projects and build types that you can select are defined by contexts for a particular target. Some options might be unavailable if they have been excluded for the target selected. To learn more about contexts and how to modify them, see the Context and Conditional build information in the CMSIS-Toolbox documentation. For example, you can use for-context and not-for-context to include or exclude target types at the project: level in the *.csolution.yml file.","title":"Active projects"},{"location":"manage_settings.html#run-and-debug","text":"Choose a run configuration and a debug configuration to use for your solution. You can select different run and debug configurations for each project included in the solution. You can also move your mouse over an entry in the list and click the pen icon to edit an existing configuration with a visual editor: Click + Add new to add a new configuration.","title":"Run and debug"},{"location":"manage_settings.html#errors-and-warnings","text":"You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. You can also go to the Problems tab and check for errors. Open the main.c file and check the IntelliSense features available. To find out about the different features, read the Visual Studio Code documentation on IntelliSense .","title":"Errors and warnings"},{"location":"quickstart.html","text":"Quick start CMSIS Solution is an extension for Visual Studio Code that provides a GUI for the underlying CMSIS-Toolbox project management and build tools. Together with other Arm and third-party extensions, the CMSIS Solution extension gives you access to a powerful embedded development environment. This quick start guide provides an overview of the project management capabilities available from the CMSIS view and shows how the status bar helps you to understand the project and environment setup. Available commands You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view . When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Manage Solution Settings Set a context for your solution Build solution Build the solution with the current context set Clean all out and tmp directories Clean all out and tmp directories for the active solution Configure Solution Set a compiler and add layers Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to the CMSIS Solution format Create a Solution Start from scratch Debug Debug the solution with the current context set Focus on Solution View Open the CMSIS view Manage software components Review, add, or remove software components Rebuild solution Rebuild the solution with the current context set Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Run Run the solution on your target Run Configuration Generator Open a generator program with the current target Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution CMSIS view The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The extension uses these settings and files to manage and build a software project for a board or device. The main area shows: Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files Status bar The Visual Studio Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Here is an example of how the status bar can look: If you have a development board connected, the connected hardware displays using the Arm Device Manager extension. Click the connected hardware to open the extension. The current debug configuration displays using the Arm Debugger extension You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"Quick start"},{"location":"quickstart.html#quick-start","text":"CMSIS Solution is an extension for Visual Studio Code that provides a GUI for the underlying CMSIS-Toolbox project management and build tools. Together with other Arm and third-party extensions, the CMSIS Solution extension gives you access to a powerful embedded development environment. This quick start guide provides an overview of the project management capabilities available from the CMSIS view and shows how the status bar helps you to understand the project and environment setup.","title":"Quick start"},{"location":"quickstart.html#available-commands","text":"You can access commands to manage your solution and the projects it includes in the following ways: From the CMSIS view . When you right-click the *.csolution.yml file from the Explorer view. When you click the Context Set status bar item . When you press Ctrl+Shift+P (Windows and Linux) or Cmd+Shift+P (macOS) to open the Command Palette. Command Description Manage Solution Settings Set a context for your solution Build solution Build the solution with the current context set Clean all out and tmp directories Clean all out and tmp directories for the active solution Configure Solution Set a compiler and add layers Convert \u00b5Vision project to CMSIS solution Convert uvprojx files to the CMSIS Solution format Create a Solution Start from scratch Debug Debug the solution with the current context set Focus on Solution View Open the CMSIS view Manage software components Review, add, or remove software components Rebuild solution Rebuild the solution with the current context set Refresh (reload packs, update RTE) Reload information from all installed packs and run cbuild setup update-rte Run Run the solution on your target Run Configuration Generator Open a generator program with the current target Select Active Solution from workspace If you have several solutions in your workspace, switch between solutions and select the active solution","title":"Available commands"},{"location":"quickstart.html#cmsis-view","text":"The CMSIS view shows the content of the active projects included in the solution. Each project contains configuration settings, source code files, build settings, and other project-specific information. The extension uses these settings and files to manage and build a software project for a board or device. The main area shows: Groups and files : Groups and user files that you add to the project and that you can edit constructed-files : Contains generated files such as the RTE_Components.h header file for each context linker : Contains a linker script file and a <regions>.h file (or other user-defined header files) Components : Shows the software components selected for the project with their source files, user code templates, and APIs. Click the files to open them in the editor. Click the book icon of a component to open the related documentation. If you are using a generator to configure your device or board, then a Run Configuration Generator option is available to start a generator session. Layer Type (if available): The software layers in the project with their source files, preconfigured software components, and configuration files","title":"CMSIS view"},{"location":"quickstart.html#status-bar","text":"The Visual Studio Code status bar displays information about the status of your development environment and the project. The number of extensions installed might vary. Here is an example of how the status bar can look: If you have a development board connected, the connected hardware displays using the Arm Device Manager extension. Click the connected hardware to open the extension. The current debug configuration displays using the Arm Debugger extension You can inspect errors and warnings for a context set. For active projects in the context set, errors and warnings display when you move your cursor over the Context Set in the status bar. The indicator is red for errors and yellow in case of warnings. Click the indicator to open the Output tab for the CMSIS Solution category. If you previously closed the Manage Solution view, then this action also re-opens the view. The Arm Tools Environment Manager extension shows information about the tools installed. Move your mouse over Arm Tools to review the list. Click Arm Tools to get more options. If you are using licensed Arm tools, the active license displays. Click the active license to manage it.","title":"Status bar"},{"location":"runexternal.html","text":"Run external tools Visual Studio Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases. Variables Visual Studio Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the Visual Studio Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view. Substitution examples The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml Examples pyOCD Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] } Arm Debugger Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] } Use \u00b5Vision for debugging The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in Visual Studio Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Run external tools"},{"location":"runexternal.html#run-external-tools","text":"Visual Studio Code uses the launch.json and tasks.json configuration files to integrate with external tools. The following section shows how to configure these files for typical use cases.","title":"Run external tools"},{"location":"runexternal.html#variables","text":"Visual Studio Code supports variable substitution in the Debugging and Tasks configuration files and selected settings. Variable substitution uses the ${variableName} syntax, for example in launch.json and tasks.json files. In addition to the Visual Studio Code built-in variables , the CMSIS Solution extension provides the following variables. Variable Description ${command:cmsis-csolution.getBinaryFile} The path and name of the first ELF/DWARF file available for the Active Target ${command:cmsis-csolution.getBinaryFiles} The paths and names of the ELF/DWARF files (comma separated) available for the Active Target ${command:cmsis-csolution.getBoardName} The board name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getBspName} The Board Support Pack (BSP) for the Active Target ${command:cmsis-csolution.getBspPath} The path to the content of the BSP for the Active Target ${command:cmsis-csolution.getCbuildRunFile} The path to the cbuild-run.yml file for the Active Target ${command:cmsis-csolution.getDeviceName} The device name for the Active Target as specified in the csolution.yml ${command:cmsis-csolution.getDfpName} The Device Family Pack (DFP) for the Active Target ${command:cmsis-csolution.getDfpPath} The path to the content of the DFP for the Active Target ${command:cmsis-csolution.getSolutionFile} The path to the csolution.yml file for the Active Solution Note Active Solution refers to the csolution project that is currently loaded. Active Target refers to the target that is currently selected in the Manage Solution view.","title":"Variables"},{"location":"runexternal.html#substitution-examples","text":"The following table illustrates the variable substition using the DualCore csolution example . Note that ... stands for the absolute path on the host computer that stores the csolution project or the CMSIS pack content . Variable Substitution ${command:cmsis-csolution.getBinaryFile} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf ${command:cmsis-csolution.getBinaryFiles} .../DualCore/out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf, .../DualCore/out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf ${command:cmsis-csolution.getBoardName} K32L3A60VPJ1A ${command:cmsis-csolution.getBspName} NXP::FRDM-K32L3A6_BSP@19.0.0 ${command:cmsis-csolution.getBspPath} .../NXP/FRDM-K32L3A6_BSP/19.0.0 ${command:cmsis-csolution.getCbuildRunFile} .../DualCore/DualCore+FRDM-K32L3A6.cbuild-run.yml ${command:cmsis-csolution.getDeviceName} K32L3A60VPJ1A ${command:cmsis-csolution.getDfpName} NXP::K32L3A60_DFP@19.0.0 ${command:cmsis-csolution.getDfpPath} .../NXP/K32L3A60_DFP/19.0.0 ${command:cmsis-csolution.getSolutionFile} .../DualCore/HelloWorld.csolution.yml","title":"Substitution examples"},{"location":"runexternal.html#examples","text":"","title":"Examples"},{"location":"runexternal.html#pyocd","text":"Use the following launch.json file to start debugging with pyOCD: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdbtarget\", \"request\": \"launch\", \"name\": \"Debug with pyOCD\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"cwd\": \"${workspaceFolder}\", \"verbose\": true, \"gdb\": \"/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/bin/arm-none-eabi-gdb\", \"initCommands\": [ \"monitor set reset-type SW_EMULATED\", \"monitor reset halt\" ], \"target\": { \"server\": \"python\", \"serverParameters\": [ \"-mpyocd\", \"gdbserver\", \"--target\", \"${command:cmsis-csolution.getDeviceName}\", \"--pack\", \"${command:cmsis-csolution.getDfpPath}\", \"--port\", \"3333\" ], \"port\": \"3333\" } } ] }","title":"pyOCD"},{"location":"runexternal.html#arm-debugger","text":"Use the following launch.json file to start Arm Debugger: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Arm Debugger\", \"type\": \"arm-debugger\", \"request\": \"launch\", \"serialNumber\": \"${command:device-manager.getSerialNumber}\", \"programs\": \"${command:cmsis-csolution.getBinaryFiles}\", \"cmsisPack\": \"${command:cmsis-csolution.getDfpPack}\", \"deviceName\": \"${command:cmsis-csolution.getDeviceName}\", } ] }","title":"Arm Debugger"},{"location":"runexternal.html#use-vision-for-debugging","text":"The \u00b5Vision debugger offers advanced debug features such as Event Recorder and Component Viewer to analyze applications. To call \u00b5Vision with the csolution project that you are using in Visual Studio Code, add the following task to the .vscode\\tasks.json file. The command: is the path to the \u00b5Vision executable on your computer. \"tasks\": [ { \"label\": \"Start uVision\", \"type\": \"process\", \"command\": \"C:\\\\Keil_v5\\\\UV4\\\\UV4.exe\", \"args\": [ \"${command:cmsis-csolution.getSolutionFile}\" ], \"problemMatcher\": [] } ] Note This only works in Windows environments with \u00b5Vision installed on the local machine.","title":"Use \u00b5Vision for debugging"},{"location":"tipsandtricks.html","text":"Tips and tricks This chapter contains useful information to help you solve specific issues. Initialize your solution Examples from keil.arm.com or solutions you create from scratch from the Create Solution view are already initialized and contain all the required files. If your solution does not contain the vcpkg-configuration.json , tasks.json , and launch.json files, use the Initialize CMSIS project option to generate them. Right-click anywhere in the workspace and select Initialize CMSIS project . The extension generates preconfigured files that are ready to use. Set current solution in workspace To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions .","title":"Tips and tricks"},{"location":"tipsandtricks.html#tips-and-tricks","text":"This chapter contains useful information to help you solve specific issues.","title":"Tips and tricks"},{"location":"tipsandtricks.html#initialize-your-solution","text":"Examples from keil.arm.com or solutions you create from scratch from the Create Solution view are already initialized and contain all the required files. If your solution does not contain the vcpkg-configuration.json , tasks.json , and launch.json files, use the Initialize CMSIS project option to generate them. Right-click anywhere in the workspace and select Initialize CMSIS project . The extension generates preconfigured files that are ready to use.","title":"Initialize your solution"},{"location":"tipsandtricks.html#set-current-solution-in-workspace","text":"To activate a solution in the Solution outline view, use the Select Active Solution from workspace option in Views and More Actions .","title":"Set current solution in workspace"}]}